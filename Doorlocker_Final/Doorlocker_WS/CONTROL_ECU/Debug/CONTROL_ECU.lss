
CONTROL_ECU.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002b66  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000016  00800060  00002b66  00002bfa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000004  00800076  00800076  00002c10  2**0
                  ALLOC
  3 .stab         000035d0  00000000  00000000  00002c10  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000208a  00000000  00000000  000061e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0000826a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  000083aa  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  0000851a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  0000a163  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  0000b04e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  0000bdfc  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  0000bf5c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  0000c1e9  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0000c9b7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 a3 05 	jmp	0xb46	; 0xb46 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 d6 05 	jmp	0xbac	; 0xbac <__vector_9>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 e6       	ldi	r30, 0x66	; 102
      68:	fb e2       	ldi	r31, 0x2B	; 43
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a6 37       	cpi	r26, 0x76	; 118
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	10 e0       	ldi	r17, 0x00	; 0
      78:	a6 e7       	ldi	r26, 0x76	; 118
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	aa 37       	cpi	r26, 0x7A	; 122
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 a1 0c 	call	0x1942	; 0x1942 <main>
      8a:	0c 94 b1 15 	jmp	0x2b62	; 0x2b62 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 7a 15 	jmp	0x2af4	; 0x2af4 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a0 e6       	ldi	r26, 0x60	; 96
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 96 15 	jmp	0x2b2c	; 0x2b2c <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 86 15 	jmp	0x2b0c	; 0x2b0c <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 a2 15 	jmp	0x2b44	; 0x2b44 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 86 15 	jmp	0x2b0c	; 0x2b0c <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 a2 15 	jmp	0x2b44	; 0x2b44 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 7a 15 	jmp	0x2af4	; 0x2af4 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	80 e6       	ldi	r24, 0x60	; 96
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 96 15 	jmp	0x2b2c	; 0x2b2c <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 86 15 	jmp	0x2b0c	; 0x2b0c <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 a2 15 	jmp	0x2b44	; 0x2b44 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 86 15 	jmp	0x2b0c	; 0x2b0c <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 a2 15 	jmp	0x2b44	; 0x2b44 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 86 15 	jmp	0x2b0c	; 0x2b0c <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 a2 15 	jmp	0x2b44	; 0x2b44 <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 8a 15 	jmp	0x2b14	; 0x2b14 <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 a6 15 	jmp	0x2b4c	; 0x2b4c <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <__vector_7>:

static uint8 counter=0;


ISR(TIMER1_COMPA_vect)
{
     b46:	1f 92       	push	r1
     b48:	0f 92       	push	r0
     b4a:	0f b6       	in	r0, 0x3f	; 63
     b4c:	0f 92       	push	r0
     b4e:	11 24       	eor	r1, r1
     b50:	2f 93       	push	r18
     b52:	3f 93       	push	r19
     b54:	4f 93       	push	r20
     b56:	5f 93       	push	r21
     b58:	6f 93       	push	r22
     b5a:	7f 93       	push	r23
     b5c:	8f 93       	push	r24
     b5e:	9f 93       	push	r25
     b60:	af 93       	push	r26
     b62:	bf 93       	push	r27
     b64:	ef 93       	push	r30
     b66:	ff 93       	push	r31
     b68:	df 93       	push	r29
     b6a:	cf 93       	push	r28
     b6c:	cd b7       	in	r28, 0x3d	; 61
     b6e:	de b7       	in	r29, 0x3e	; 62
	if(g_callBackPtr !=NULL_PTR)
     b70:	80 91 76 00 	lds	r24, 0x0076
     b74:	90 91 77 00 	lds	r25, 0x0077
     b78:	00 97       	sbiw	r24, 0x00	; 0
     b7a:	29 f0       	breq	.+10     	; 0xb86 <__vector_7+0x40>
	{
		(*g_callBackPtr)();
     b7c:	e0 91 76 00 	lds	r30, 0x0076
     b80:	f0 91 77 00 	lds	r31, 0x0077
     b84:	09 95       	icall
	}
}
     b86:	cf 91       	pop	r28
     b88:	df 91       	pop	r29
     b8a:	ff 91       	pop	r31
     b8c:	ef 91       	pop	r30
     b8e:	bf 91       	pop	r27
     b90:	af 91       	pop	r26
     b92:	9f 91       	pop	r25
     b94:	8f 91       	pop	r24
     b96:	7f 91       	pop	r23
     b98:	6f 91       	pop	r22
     b9a:	5f 91       	pop	r21
     b9c:	4f 91       	pop	r20
     b9e:	3f 91       	pop	r19
     ba0:	2f 91       	pop	r18
     ba2:	0f 90       	pop	r0
     ba4:	0f be       	out	0x3f, r0	; 63
     ba6:	0f 90       	pop	r0
     ba8:	1f 90       	pop	r1
     baa:	18 95       	reti

00000bac <__vector_9>:

ISR(TIMER1_OVF_vect)
{
     bac:	1f 92       	push	r1
     bae:	0f 92       	push	r0
     bb0:	0f b6       	in	r0, 0x3f	; 63
     bb2:	0f 92       	push	r0
     bb4:	11 24       	eor	r1, r1
     bb6:	2f 93       	push	r18
     bb8:	3f 93       	push	r19
     bba:	4f 93       	push	r20
     bbc:	5f 93       	push	r21
     bbe:	6f 93       	push	r22
     bc0:	7f 93       	push	r23
     bc2:	8f 93       	push	r24
     bc4:	9f 93       	push	r25
     bc6:	af 93       	push	r26
     bc8:	bf 93       	push	r27
     bca:	ef 93       	push	r30
     bcc:	ff 93       	push	r31
     bce:	df 93       	push	r29
     bd0:	cf 93       	push	r28
     bd2:	cd b7       	in	r28, 0x3d	; 61
     bd4:	de b7       	in	r29, 0x3e	; 62
	if(g_callBackPtr != NULL_PTR)
     bd6:	80 91 76 00 	lds	r24, 0x0076
     bda:	90 91 77 00 	lds	r25, 0x0077
     bde:	00 97       	sbiw	r24, 0x00	; 0
     be0:	39 f0       	breq	.+14     	; 0xbf0 <__vector_9+0x44>
	{ 	(*g_callBackPtr)();
     be2:	e0 91 76 00 	lds	r30, 0x0076
     be6:	f0 91 77 00 	lds	r31, 0x0077
     bea:	09 95       	icall
		 counter=0;	}
     bec:	10 92 78 00 	sts	0x0078, r1
}
     bf0:	cf 91       	pop	r28
     bf2:	df 91       	pop	r29
     bf4:	ff 91       	pop	r31
     bf6:	ef 91       	pop	r30
     bf8:	bf 91       	pop	r27
     bfa:	af 91       	pop	r26
     bfc:	9f 91       	pop	r25
     bfe:	8f 91       	pop	r24
     c00:	7f 91       	pop	r23
     c02:	6f 91       	pop	r22
     c04:	5f 91       	pop	r21
     c06:	4f 91       	pop	r20
     c08:	3f 91       	pop	r19
     c0a:	2f 91       	pop	r18
     c0c:	0f 90       	pop	r0
     c0e:	0f be       	out	0x3f, r0	; 63
     c10:	0f 90       	pop	r0
     c12:	1f 90       	pop	r1
     c14:	18 95       	reti

00000c16 <Timer1_init>:

/*
 * Function to initialize the Timer driver
*/
void Timer1_init(const Timer1_ConfigType *Config_Ptr)
{
     c16:	df 93       	push	r29
     c18:	cf 93       	push	r28
     c1a:	00 d0       	rcall	.+0      	; 0xc1c <Timer1_init+0x6>
     c1c:	cd b7       	in	r28, 0x3d	; 61
     c1e:	de b7       	in	r29, 0x3e	; 62
     c20:	9a 83       	std	Y+2, r25	; 0x02
     c22:	89 83       	std	Y+1, r24	; 0x01

	//FOC1A & FOC1B for Non PWM mode
	TCCR1A =(1<<FOC1A) | (1<<FOC1B);
     c24:	ef e4       	ldi	r30, 0x4F	; 79
     c26:	f0 e0       	ldi	r31, 0x00	; 0
     c28:	8c e0       	ldi	r24, 0x0C	; 12
     c2a:	80 83       	st	Z, r24
	// Prescaler bits are  CS10,CS11,CS12
	TCCR1B =(TCCR1B& 0xF8)|(Config_Ptr->prescaler);
     c2c:	ae e4       	ldi	r26, 0x4E	; 78
     c2e:	b0 e0       	ldi	r27, 0x00	; 0
     c30:	ee e4       	ldi	r30, 0x4E	; 78
     c32:	f0 e0       	ldi	r31, 0x00	; 0
     c34:	80 81       	ld	r24, Z
     c36:	98 2f       	mov	r25, r24
     c38:	98 7f       	andi	r25, 0xF8	; 248
     c3a:	e9 81       	ldd	r30, Y+1	; 0x01
     c3c:	fa 81       	ldd	r31, Y+2	; 0x02
     c3e:	82 81       	ldd	r24, Z+2	; 0x02
     c40:	89 2b       	or	r24, r25
     c42:	8c 93       	st	X, r24
	// Initial value to start counting from
	TCNT1 = Config_Ptr->initial_value;
     c44:	ac e4       	ldi	r26, 0x4C	; 76
     c46:	b0 e0       	ldi	r27, 0x00	; 0
     c48:	e9 81       	ldd	r30, Y+1	; 0x01
     c4a:	fa 81       	ldd	r31, Y+2	; 0x02
     c4c:	80 81       	ld	r24, Z
     c4e:	91 81       	ldd	r25, Z+1	; 0x01
     c50:	11 96       	adiw	r26, 0x01	; 1
     c52:	9c 93       	st	X, r25
     c54:	8e 93       	st	-X, r24

	//For compare
	if(Config_Ptr->mode == COMPARE)
     c56:	e9 81       	ldd	r30, Y+1	; 0x01
     c58:	fa 81       	ldd	r31, Y+2	; 0x02
     c5a:	83 81       	ldd	r24, Z+3	; 0x03
     c5c:	81 30       	cpi	r24, 0x01	; 1
     c5e:	a9 f4       	brne	.+42     	; 0xc8a <Timer1_init+0x74>
	{
			OCR1A = Config_Ptr->compare_value;
     c60:	aa e4       	ldi	r26, 0x4A	; 74
     c62:	b0 e0       	ldi	r27, 0x00	; 0
     c64:	e9 81       	ldd	r30, Y+1	; 0x01
     c66:	fa 81       	ldd	r31, Y+2	; 0x02
     c68:	84 81       	ldd	r24, Z+4	; 0x04
     c6a:	95 81       	ldd	r25, Z+5	; 0x05
     c6c:	11 96       	adiw	r26, 0x01	; 1
     c6e:	9c 93       	st	X, r25
     c70:	8e 93       	st	-X, r24
			// Timer1 Compare Interrupt
			TIMSK = (1<<OCIE1A);
     c72:	e9 e5       	ldi	r30, 0x59	; 89
     c74:	f0 e0       	ldi	r31, 0x00	; 0
     c76:	80 e1       	ldi	r24, 0x10	; 16
     c78:	80 83       	st	Z, r24
			//WGM12 for compare mode WMG11:10 =0
			TCCR1B |= (1<<WGM12);
     c7a:	ae e4       	ldi	r26, 0x4E	; 78
     c7c:	b0 e0       	ldi	r27, 0x00	; 0
     c7e:	ee e4       	ldi	r30, 0x4E	; 78
     c80:	f0 e0       	ldi	r31, 0x00	; 0
     c82:	80 81       	ld	r24, Z
     c84:	88 60       	ori	r24, 0x08	; 8
     c86:	8c 93       	st	X, r24
     c88:	09 c0       	rjmp	.+18     	; 0xc9c <Timer1_init+0x86>
	}
	//For Normal
	else if(Config_Ptr->mode == NORMAL)
     c8a:	e9 81       	ldd	r30, Y+1	; 0x01
     c8c:	fa 81       	ldd	r31, Y+2	; 0x02
     c8e:	83 81       	ldd	r24, Z+3	; 0x03
     c90:	88 23       	and	r24, r24
     c92:	21 f4       	brne	.+8      	; 0xc9c <Timer1_init+0x86>
	{
			TIMSK =(1<<TOIE1);} // Turning on normal mode interrupt
     c94:	e9 e5       	ldi	r30, 0x59	; 89
     c96:	f0 e0       	ldi	r31, 0x00	; 0
     c98:	84 e0       	ldi	r24, 0x04	; 4
     c9a:	80 83       	st	Z, r24
}
     c9c:	0f 90       	pop	r0
     c9e:	0f 90       	pop	r0
     ca0:	cf 91       	pop	r28
     ca2:	df 91       	pop	r29
     ca4:	08 95       	ret

00000ca6 <Timer1_deInit>:
void Timer1_deInit(void)
{
     ca6:	df 93       	push	r29
     ca8:	cf 93       	push	r28
     caa:	cd b7       	in	r28, 0x3d	; 61
     cac:	de b7       	in	r29, 0x3e	; 62
	//Clearing all timer registers
	TCCR1A=0;
     cae:	ef e4       	ldi	r30, 0x4F	; 79
     cb0:	f0 e0       	ldi	r31, 0x00	; 0
     cb2:	10 82       	st	Z, r1
	 TCCR1B=0;
     cb4:	ee e4       	ldi	r30, 0x4E	; 78
     cb6:	f0 e0       	ldi	r31, 0x00	; 0
     cb8:	10 82       	st	Z, r1
	TCNT1=0;
     cba:	ec e4       	ldi	r30, 0x4C	; 76
     cbc:	f0 e0       	ldi	r31, 0x00	; 0
     cbe:	11 82       	std	Z+1, r1	; 0x01
     cc0:	10 82       	st	Z, r1
	OCR1A=0;
     cc2:	ea e4       	ldi	r30, 0x4A	; 74
     cc4:	f0 e0       	ldi	r31, 0x00	; 0
     cc6:	11 82       	std	Z+1, r1	; 0x01
     cc8:	10 82       	st	Z, r1

	// Clearing all 4 Interrupt enable bits
	TIMSK &= (0xC3);
     cca:	a9 e5       	ldi	r26, 0x59	; 89
     ccc:	b0 e0       	ldi	r27, 0x00	; 0
     cce:	e9 e5       	ldi	r30, 0x59	; 89
     cd0:	f0 e0       	ldi	r31, 0x00	; 0
     cd2:	80 81       	ld	r24, Z
     cd4:	83 7c       	andi	r24, 0xC3	; 195
     cd6:	8c 93       	st	X, r24
	 counter=0;
     cd8:	10 92 78 00 	sts	0x0078, r1
	g_callBackPtr = NULL_PTR;
     cdc:	10 92 77 00 	sts	0x0077, r1
     ce0:	10 92 76 00 	sts	0x0076, r1
}
     ce4:	cf 91       	pop	r28
     ce6:	df 91       	pop	r29
     ce8:	08 95       	ret

00000cea <Timer1_setCallBack>:

void Timer1_setCallBack(void(*a_ptr)(void))
{
     cea:	df 93       	push	r29
     cec:	cf 93       	push	r28
     cee:	00 d0       	rcall	.+0      	; 0xcf0 <Timer1_setCallBack+0x6>
     cf0:	cd b7       	in	r28, 0x3d	; 61
     cf2:	de b7       	in	r29, 0x3e	; 62
     cf4:	9a 83       	std	Y+2, r25	; 0x02
     cf6:	89 83       	std	Y+1, r24	; 0x01
	g_callBackPtr = a_ptr;
     cf8:	89 81       	ldd	r24, Y+1	; 0x01
     cfa:	9a 81       	ldd	r25, Y+2	; 0x02
     cfc:	90 93 77 00 	sts	0x0077, r25
     d00:	80 93 76 00 	sts	0x0076, r24
}
     d04:	0f 90       	pop	r0
     d06:	0f 90       	pop	r0
     d08:	cf 91       	pop	r28
     d0a:	df 91       	pop	r29
     d0c:	08 95       	ret

00000d0e <UART_init>:

/*
 * Description :
 * Function for Initialize the UART device Configurable
 */
void UART_init(const UART_ConfigType *Config_Ptr) {
     d0e:	df 93       	push	r29
     d10:	cf 93       	push	r28
     d12:	00 d0       	rcall	.+0      	; 0xd14 <UART_init+0x6>
     d14:	00 d0       	rcall	.+0      	; 0xd16 <UART_init+0x8>
     d16:	cd b7       	in	r28, 0x3d	; 61
     d18:	de b7       	in	r29, 0x3e	; 62
     d1a:	9c 83       	std	Y+4, r25	; 0x04
     d1c:	8b 83       	std	Y+3, r24	; 0x03
	uint16  ubrr_value = 0;
     d1e:	1a 82       	std	Y+2, r1	; 0x02
     d20:	19 82       	std	Y+1, r1	; 0x01
	UCSRA =(1<<U2X); // double speed
     d22:	eb e2       	ldi	r30, 0x2B	; 43
     d24:	f0 e0       	ldi	r31, 0x00	; 0
     d26:	82 e0       	ldi	r24, 0x02	; 2
     d28:	80 83       	st	Z, r24
	 /* RXEN  = 1 Receiver Enable
	 * RXEN  = 1 Transmitter Enable
	 */
	UCSRB =(1<<RXEN)|(1<<TXEN);
     d2a:	ea e2       	ldi	r30, 0x2A	; 42
     d2c:	f0 e0       	ldi	r31, 0x00	; 0
     d2e:	88 e1       	ldi	r24, 0x18	; 24
     d30:	80 83       	st	Z, r24
	 * UPM1:0  = 10 Even parity bit
	 * USBS    = 0 One stop bit
	 * UCSZ1:0 = 11 For 8-bit data mode
	 * UCPOL   = 0 write to 0 at async operaton
	 */
	UCSRC = (1 << URSEL) | (Config_Ptr->bit_data<< UCSZ0) | (Config_Ptr->parity<< UPM0) | (Config_Ptr->stop_bit<< USBS);
     d32:	a0 e4       	ldi	r26, 0x40	; 64
     d34:	b0 e0       	ldi	r27, 0x00	; 0
     d36:	eb 81       	ldd	r30, Y+3	; 0x03
     d38:	fc 81       	ldd	r31, Y+4	; 0x04
     d3a:	80 81       	ld	r24, Z
     d3c:	88 2f       	mov	r24, r24
     d3e:	90 e0       	ldi	r25, 0x00	; 0
     d40:	88 0f       	add	r24, r24
     d42:	99 1f       	adc	r25, r25
     d44:	28 2f       	mov	r18, r24
     d46:	20 68       	ori	r18, 0x80	; 128
     d48:	eb 81       	ldd	r30, Y+3	; 0x03
     d4a:	fc 81       	ldd	r31, Y+4	; 0x04
     d4c:	81 81       	ldd	r24, Z+1	; 0x01
     d4e:	88 2f       	mov	r24, r24
     d50:	90 e0       	ldi	r25, 0x00	; 0
     d52:	82 95       	swap	r24
     d54:	92 95       	swap	r25
     d56:	90 7f       	andi	r25, 0xF0	; 240
     d58:	98 27       	eor	r25, r24
     d5a:	80 7f       	andi	r24, 0xF0	; 240
     d5c:	98 27       	eor	r25, r24
     d5e:	28 2b       	or	r18, r24
     d60:	eb 81       	ldd	r30, Y+3	; 0x03
     d62:	fc 81       	ldd	r31, Y+4	; 0x04
     d64:	82 81       	ldd	r24, Z+2	; 0x02
     d66:	88 2f       	mov	r24, r24
     d68:	90 e0       	ldi	r25, 0x00	; 0
     d6a:	88 0f       	add	r24, r24
     d6c:	99 1f       	adc	r25, r25
     d6e:	88 0f       	add	r24, r24
     d70:	99 1f       	adc	r25, r25
     d72:	88 0f       	add	r24, r24
     d74:	99 1f       	adc	r25, r25
     d76:	82 2b       	or	r24, r18
     d78:	8c 93       	st	X, r24

	//Calculate the UBRR register value
	ubrr_value = (uint16)(((F_CPU / (Config_Ptr->baud_rate * 8UL))) - 1);
     d7a:	eb 81       	ldd	r30, Y+3	; 0x03
     d7c:	fc 81       	ldd	r31, Y+4	; 0x04
     d7e:	83 81       	ldd	r24, Z+3	; 0x03
     d80:	94 81       	ldd	r25, Z+4	; 0x04
     d82:	cc 01       	movw	r24, r24
     d84:	a0 e0       	ldi	r26, 0x00	; 0
     d86:	b0 e0       	ldi	r27, 0x00	; 0
     d88:	88 0f       	add	r24, r24
     d8a:	99 1f       	adc	r25, r25
     d8c:	aa 1f       	adc	r26, r26
     d8e:	bb 1f       	adc	r27, r27
     d90:	88 0f       	add	r24, r24
     d92:	99 1f       	adc	r25, r25
     d94:	aa 1f       	adc	r26, r26
     d96:	bb 1f       	adc	r27, r27
     d98:	88 0f       	add	r24, r24
     d9a:	99 1f       	adc	r25, r25
     d9c:	aa 1f       	adc	r26, r26
     d9e:	bb 1f       	adc	r27, r27
     da0:	9c 01       	movw	r18, r24
     da2:	ad 01       	movw	r20, r26
     da4:	80 e0       	ldi	r24, 0x00	; 0
     da6:	92 e1       	ldi	r25, 0x12	; 18
     da8:	aa e7       	ldi	r26, 0x7A	; 122
     daa:	b0 e0       	ldi	r27, 0x00	; 0
     dac:	bc 01       	movw	r22, r24
     dae:	cd 01       	movw	r24, r26
     db0:	0e 94 58 15 	call	0x2ab0	; 0x2ab0 <__udivmodsi4>
     db4:	da 01       	movw	r26, r20
     db6:	c9 01       	movw	r24, r18
     db8:	01 97       	sbiw	r24, 0x01	; 1
     dba:	9a 83       	std	Y+2, r25	; 0x02
     dbc:	89 83       	std	Y+1, r24	; 0x01
	UBRRH = ubrr_value >> 8;
     dbe:	e0 e4       	ldi	r30, 0x40	; 64
     dc0:	f0 e0       	ldi	r31, 0x00	; 0
     dc2:	89 81       	ldd	r24, Y+1	; 0x01
     dc4:	9a 81       	ldd	r25, Y+2	; 0x02
     dc6:	89 2f       	mov	r24, r25
     dc8:	99 27       	eor	r25, r25
     dca:	80 83       	st	Z, r24
	UBRRL = ubrr_value;
     dcc:	e9 e2       	ldi	r30, 0x29	; 41
     dce:	f0 e0       	ldi	r31, 0x00	; 0
     dd0:	89 81       	ldd	r24, Y+1	; 0x01
     dd2:	80 83       	st	Z, r24
}
     dd4:	0f 90       	pop	r0
     dd6:	0f 90       	pop	r0
     dd8:	0f 90       	pop	r0
     dda:	0f 90       	pop	r0
     ddc:	cf 91       	pop	r28
     dde:	df 91       	pop	r29
     de0:	08 95       	ret

00000de2 <UART_sendByte>:
/*
 * Description :
 * Functional responsible for send byte to another UART device.
 */
void UART_sendByte(const uint8 data)
{
     de2:	df 93       	push	r29
     de4:	cf 93       	push	r28
     de6:	0f 92       	push	r0
     de8:	cd b7       	in	r28, 0x3d	; 61
     dea:	de b7       	in	r29, 0x3e	; 62
     dec:	89 83       	std	Y+1, r24	; 0x01
	/*
	 * UDRE flag is set when the Tx buffer (UDR) is empty and ready for
	 * transmitting a new byte so wait until this flag is set to one
	 */
	while(BIT_IS_CLEAR(UCSRA,UDRE)){}
     dee:	eb e2       	ldi	r30, 0x2B	; 43
     df0:	f0 e0       	ldi	r31, 0x00	; 0
     df2:	80 81       	ld	r24, Z
     df4:	88 2f       	mov	r24, r24
     df6:	90 e0       	ldi	r25, 0x00	; 0
     df8:	80 72       	andi	r24, 0x20	; 32
     dfa:	90 70       	andi	r25, 0x00	; 0
     dfc:	00 97       	sbiw	r24, 0x00	; 0
     dfe:	b9 f3       	breq	.-18     	; 0xdee <UART_sendByte+0xc>

	/*
	 * Put the required data in the UDR register and it also clear the UDRE flag as
	 * the UDR register is not empty now
	 */
	UDR = data;
     e00:	ec e2       	ldi	r30, 0x2C	; 44
     e02:	f0 e0       	ldi	r31, 0x00	; 0
     e04:	89 81       	ldd	r24, Y+1	; 0x01
     e06:	80 83       	st	Z, r24
	/************************* Another Method *************************
	UDR = data;
	while(BIT_IS_CLEAR(UCSRA,TXC)){} // Wait until the transmission is complete TXC = 1
	SET_BIT(UCSRA,TXC); // Clear the TXC flag
	*******************************************************************/
}
     e08:	0f 90       	pop	r0
     e0a:	cf 91       	pop	r28
     e0c:	df 91       	pop	r29
     e0e:	08 95       	ret

00000e10 <UART_recieveByte>:
 * Description :
 * Functional responsible for receive byte from another UART device by polling.
 */

uint8 UART_recieveByte(void)
{
     e10:	df 93       	push	r29
     e12:	cf 93       	push	r28
     e14:	cd b7       	in	r28, 0x3d	; 61
     e16:	de b7       	in	r29, 0x3e	; 62
	/* RXC flag is set when the UART receive data so wait until this flag is set to one */
	while(BIT_IS_CLEAR(UCSRA,RXC)){}
     e18:	eb e2       	ldi	r30, 0x2B	; 43
     e1a:	f0 e0       	ldi	r31, 0x00	; 0
     e1c:	80 81       	ld	r24, Z
     e1e:	88 23       	and	r24, r24
     e20:	dc f7       	brge	.-10     	; 0xe18 <UART_recieveByte+0x8>

	/*
	 * Read the received data from the Rx buffer (UDR)
	 * The RXC flag will be cleared after read the data
	 */
    return UDR;
     e22:	ec e2       	ldi	r30, 0x2C	; 44
     e24:	f0 e0       	ldi	r31, 0x00	; 0
     e26:	80 81       	ld	r24, Z
}
     e28:	cf 91       	pop	r28
     e2a:	df 91       	pop	r29
     e2c:	08 95       	ret

00000e2e <UART_sendString>:
/*
 * Description :
 * Send the required string through UART to the other UART device.
 */
void UART_sendString(const uint8 *Str)
{
     e2e:	df 93       	push	r29
     e30:	cf 93       	push	r28
     e32:	00 d0       	rcall	.+0      	; 0xe34 <UART_sendString+0x6>
     e34:	0f 92       	push	r0
     e36:	cd b7       	in	r28, 0x3d	; 61
     e38:	de b7       	in	r29, 0x3e	; 62
     e3a:	9b 83       	std	Y+3, r25	; 0x03
     e3c:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
     e3e:	19 82       	std	Y+1, r1	; 0x01
     e40:	0e c0       	rjmp	.+28     	; 0xe5e <UART_sendString+0x30>

	/* Send the whole string */
	while(Str[i] != '\0')
	{
		UART_sendByte(Str[i]);
     e42:	89 81       	ldd	r24, Y+1	; 0x01
     e44:	28 2f       	mov	r18, r24
     e46:	30 e0       	ldi	r19, 0x00	; 0
     e48:	8a 81       	ldd	r24, Y+2	; 0x02
     e4a:	9b 81       	ldd	r25, Y+3	; 0x03
     e4c:	fc 01       	movw	r30, r24
     e4e:	e2 0f       	add	r30, r18
     e50:	f3 1f       	adc	r31, r19
     e52:	80 81       	ld	r24, Z
     e54:	0e 94 f1 06 	call	0xde2	; 0xde2 <UART_sendByte>
		i++;
     e58:	89 81       	ldd	r24, Y+1	; 0x01
     e5a:	8f 5f       	subi	r24, 0xFF	; 255
     e5c:	89 83       	std	Y+1, r24	; 0x01
void UART_sendString(const uint8 *Str)
{
	uint8 i = 0;

	/* Send the whole string */
	while(Str[i] != '\0')
     e5e:	89 81       	ldd	r24, Y+1	; 0x01
     e60:	28 2f       	mov	r18, r24
     e62:	30 e0       	ldi	r19, 0x00	; 0
     e64:	8a 81       	ldd	r24, Y+2	; 0x02
     e66:	9b 81       	ldd	r25, Y+3	; 0x03
     e68:	fc 01       	movw	r30, r24
     e6a:	e2 0f       	add	r30, r18
     e6c:	f3 1f       	adc	r31, r19
     e6e:	80 81       	ld	r24, Z
     e70:	88 23       	and	r24, r24
     e72:	39 f7       	brne	.-50     	; 0xe42 <UART_sendString+0x14>
	{
		UART_sendByte(*Str);
		Str++;
	}
	*******************************************************************/
}
     e74:	0f 90       	pop	r0
     e76:	0f 90       	pop	r0
     e78:	0f 90       	pop	r0
     e7a:	cf 91       	pop	r28
     e7c:	df 91       	pop	r29
     e7e:	08 95       	ret

00000e80 <UART_receiveString>:
/*
 * Description :
 * Receive the required string until the '#' symbol through UART from the other UART device.
 */
void UART_receiveString(uint8 *Str)
{
     e80:	0f 93       	push	r16
     e82:	1f 93       	push	r17
     e84:	df 93       	push	r29
     e86:	cf 93       	push	r28
     e88:	00 d0       	rcall	.+0      	; 0xe8a <UART_receiveString+0xa>
     e8a:	0f 92       	push	r0
     e8c:	cd b7       	in	r28, 0x3d	; 61
     e8e:	de b7       	in	r29, 0x3e	; 62
     e90:	9b 83       	std	Y+3, r25	; 0x03
     e92:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
     e94:	19 82       	std	Y+1, r1	; 0x01

	/* Receive the first byte */
	Str[i] = UART_recieveByte();
     e96:	89 81       	ldd	r24, Y+1	; 0x01
     e98:	28 2f       	mov	r18, r24
     e9a:	30 e0       	ldi	r19, 0x00	; 0
     e9c:	8a 81       	ldd	r24, Y+2	; 0x02
     e9e:	9b 81       	ldd	r25, Y+3	; 0x03
     ea0:	8c 01       	movw	r16, r24
     ea2:	02 0f       	add	r16, r18
     ea4:	13 1f       	adc	r17, r19
     ea6:	0e 94 08 07 	call	0xe10	; 0xe10 <UART_recieveByte>
     eaa:	f8 01       	movw	r30, r16
     eac:	80 83       	st	Z, r24
     eae:	0f c0       	rjmp	.+30     	; 0xece <UART_receiveString+0x4e>

	/* Receive the whole string until the '#' */
	while(Str[i] != '#')
	{
		i++;
     eb0:	89 81       	ldd	r24, Y+1	; 0x01
     eb2:	8f 5f       	subi	r24, 0xFF	; 255
     eb4:	89 83       	std	Y+1, r24	; 0x01
		Str[i] = UART_recieveByte();
     eb6:	89 81       	ldd	r24, Y+1	; 0x01
     eb8:	28 2f       	mov	r18, r24
     eba:	30 e0       	ldi	r19, 0x00	; 0
     ebc:	8a 81       	ldd	r24, Y+2	; 0x02
     ebe:	9b 81       	ldd	r25, Y+3	; 0x03
     ec0:	8c 01       	movw	r16, r24
     ec2:	02 0f       	add	r16, r18
     ec4:	13 1f       	adc	r17, r19
     ec6:	0e 94 08 07 	call	0xe10	; 0xe10 <UART_recieveByte>
     eca:	f8 01       	movw	r30, r16
     ecc:	80 83       	st	Z, r24

	/* Receive the first byte */
	Str[i] = UART_recieveByte();

	/* Receive the whole string until the '#' */
	while(Str[i] != '#')
     ece:	89 81       	ldd	r24, Y+1	; 0x01
     ed0:	28 2f       	mov	r18, r24
     ed2:	30 e0       	ldi	r19, 0x00	; 0
     ed4:	8a 81       	ldd	r24, Y+2	; 0x02
     ed6:	9b 81       	ldd	r25, Y+3	; 0x03
     ed8:	fc 01       	movw	r30, r24
     eda:	e2 0f       	add	r30, r18
     edc:	f3 1f       	adc	r31, r19
     ede:	80 81       	ld	r24, Z
     ee0:	83 32       	cpi	r24, 0x23	; 35
     ee2:	31 f7       	brne	.-52     	; 0xeb0 <UART_receiveString+0x30>
		i++;
		Str[i] = UART_recieveByte();
	}

	/* After receiving the whole string plus the '#', replace the '#' with '\0' */
	Str[i] = '\0';
     ee4:	89 81       	ldd	r24, Y+1	; 0x01
     ee6:	28 2f       	mov	r18, r24
     ee8:	30 e0       	ldi	r19, 0x00	; 0
     eea:	8a 81       	ldd	r24, Y+2	; 0x02
     eec:	9b 81       	ldd	r25, Y+3	; 0x03
     eee:	fc 01       	movw	r30, r24
     ef0:	e2 0f       	add	r30, r18
     ef2:	f3 1f       	adc	r31, r19
     ef4:	10 82       	st	Z, r1
}
     ef6:	0f 90       	pop	r0
     ef8:	0f 90       	pop	r0
     efa:	0f 90       	pop	r0
     efc:	cf 91       	pop	r28
     efe:	df 91       	pop	r29
     f00:	1f 91       	pop	r17
     f02:	0f 91       	pop	r16
     f04:	08 95       	ret

00000f06 <PWM_Timer0_Start>:
 Setup the compare value based on the required input duty cycle
 Setup the direction for OC0 as output pin through the GPIO driver.
 The generated PWM signal frequency will be 500Hz to control the DC
Motor speed.
 */
void PWM_Timer0_Start(uint8 duty_cycle){
     f06:	df 93       	push	r29
     f08:	cf 93       	push	r28
     f0a:	0f 92       	push	r0
     f0c:	cd b7       	in	r28, 0x3d	; 61
     f0e:	de b7       	in	r29, 0x3e	; 62
     f10:	89 83       	std	Y+1, r24	; 0x01

	TCNT0 = 0; // Set Timer Initial Value to 0
     f12:	e2 e5       	ldi	r30, 0x52	; 82
     f14:	f0 e0       	ldi	r31, 0x00	; 0
     f16:	10 82       	st	Z, r1
	/*
	 * Mapping from( 0 , 100 )  to (0,255) for OCR0
	 */
	OCR0  = (uint8)(((uint16)duty_cycle*255)/(100)); //Set Compare value
     f18:	ec e5       	ldi	r30, 0x5C	; 92
     f1a:	f0 e0       	ldi	r31, 0x00	; 0
     f1c:	89 81       	ldd	r24, Y+1	; 0x01
     f1e:	48 2f       	mov	r20, r24
     f20:	50 e0       	ldi	r21, 0x00	; 0
     f22:	ca 01       	movw	r24, r20
     f24:	9c 01       	movw	r18, r24
     f26:	22 0f       	add	r18, r18
     f28:	33 1f       	adc	r19, r19
     f2a:	c9 01       	movw	r24, r18
     f2c:	96 95       	lsr	r25
     f2e:	98 2f       	mov	r25, r24
     f30:	88 27       	eor	r24, r24
     f32:	97 95       	ror	r25
     f34:	87 95       	ror	r24
     f36:	82 1b       	sub	r24, r18
     f38:	93 0b       	sbc	r25, r19
     f3a:	84 0f       	add	r24, r20
     f3c:	95 1f       	adc	r25, r21
     f3e:	24 e6       	ldi	r18, 0x64	; 100
     f40:	30 e0       	ldi	r19, 0x00	; 0
     f42:	b9 01       	movw	r22, r18
     f44:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__udivmodhi4>
     f48:	cb 01       	movw	r24, r22
     f4a:	80 83       	st	Z, r24

	GPIO_setupPinDirection(PORTB_ID,PIN3_ID, LOGIC_HIGH); // Configure PB3/OC0 as output pin --> pin where the PWM signal is generated from MC
     f4c:	81 e0       	ldi	r24, 0x01	; 1
     f4e:	63 e0       	ldi	r22, 0x03	; 3
     f50:	41 e0       	ldi	r20, 0x01	; 1
     f52:	0e 94 39 08 	call	0x1072	; 0x1072 <GPIO_setupPinDirection>
	 * 1. Fast PWM mode FOC0=0
	 * 2. Fast PWM Mode WGM01=1 & WGM00=1
	 * 3. Clear OC0 when match occurs (non inverted mode) COM00=0 & COM01=1
	 * 4. clock = F_CPU/8 CS00=0 CS01=1 CS02=0
	 */
	TCCR0 = (1<<WGM00) | (1<<WGM01) | (1<<COM01) | (1<<CS01);
     f56:	e3 e5       	ldi	r30, 0x53	; 83
     f58:	f0 e0       	ldi	r31, 0x00	; 0
     f5a:	8a e6       	ldi	r24, 0x6A	; 106
     f5c:	80 83       	st	Z, r24
}
     f5e:	0f 90       	pop	r0
     f60:	cf 91       	pop	r28
     f62:	df 91       	pop	r29
     f64:	08 95       	ret

00000f66 <TWI_init>:
#include <avr/io.h>

#include "../../inc/common_macros.h"

void TWI_init(const TWI_ConfigType * Config_Ptr)
{
     f66:	df 93       	push	r29
     f68:	cf 93       	push	r28
     f6a:	00 d0       	rcall	.+0      	; 0xf6c <TWI_init+0x6>
     f6c:	cd b7       	in	r28, 0x3d	; 61
     f6e:	de b7       	in	r29, 0x3e	; 62
     f70:	9a 83       	std	Y+2, r25	; 0x02
     f72:	89 83       	std	Y+1, r24	; 0x01
	 * SCL=F_CPU/(16+2(TWBR)*4^TWPS)
	 * Prescaler/1  TWPS=00
	 * Bit rate 400kb/s
	 * F_CPU = 8MHz
	 */
		TWBR =Config_Ptr->bit_rate ;
     f74:	a0 e2       	ldi	r26, 0x20	; 32
     f76:	b0 e0       	ldi	r27, 0x00	; 0
     f78:	e9 81       	ldd	r30, Y+1	; 0x01
     f7a:	fa 81       	ldd	r31, Y+2	; 0x02
     f7c:	81 81       	ldd	r24, Z+1	; 0x01
     f7e:	8c 93       	st	X, r24
	TWSR =0;
     f80:	e1 e2       	ldi	r30, 0x21	; 33
     f82:	f0 e0       	ldi	r31, 0x00	; 0
     f84:	10 82       	st	Z, r1
	/* TWGCE bit =0 in TWAR
	 * Slave address to be called by Master
	 */
    TWAR =Config_Ptr->address ;
     f86:	a2 e2       	ldi	r26, 0x22	; 34
     f88:	b0 e0       	ldi	r27, 0x00	; 0
     f8a:	e9 81       	ldd	r30, Y+1	; 0x01
     f8c:	fa 81       	ldd	r31, Y+2	; 0x02
     f8e:	80 81       	ld	r24, Z
     f90:	8c 93       	st	X, r24
    /*
     * enable TWI bit
     */
    TWCR = (1<<TWEN);
     f92:	e6 e5       	ldi	r30, 0x56	; 86
     f94:	f0 e0       	ldi	r31, 0x00	; 0
     f96:	84 e0       	ldi	r24, 0x04	; 4
     f98:	80 83       	st	Z, r24
}
     f9a:	0f 90       	pop	r0
     f9c:	0f 90       	pop	r0
     f9e:	cf 91       	pop	r28
     fa0:	df 91       	pop	r29
     fa2:	08 95       	ret

00000fa4 <TWI_start>:

void TWI_start(void)
{
     fa4:	df 93       	push	r29
     fa6:	cf 93       	push	r28
     fa8:	cd b7       	in	r28, 0x3d	; 61
     faa:	de b7       	in	r29, 0x3e	; 62
    /*
	 * Clear the TWINT flag before sending the start bit TWINT=1
	 * send the start bit by TWSTA=1
	 * Enable TWI Module TWEN=1
	 */
    TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
     fac:	e6 e5       	ldi	r30, 0x56	; 86
     fae:	f0 e0       	ldi	r31, 0x00	; 0
     fb0:	84 ea       	ldi	r24, 0xA4	; 164
     fb2:	80 83       	st	Z, r24

    /* Wait for TWINT flag set in TWCR Register (start bit is send successfully) */
    while(BIT_IS_CLEAR(TWCR,TWINT));
     fb4:	e6 e5       	ldi	r30, 0x56	; 86
     fb6:	f0 e0       	ldi	r31, 0x00	; 0
     fb8:	80 81       	ld	r24, Z
     fba:	88 23       	and	r24, r24
     fbc:	dc f7       	brge	.-10     	; 0xfb4 <TWI_start+0x10>
}
     fbe:	cf 91       	pop	r28
     fc0:	df 91       	pop	r29
     fc2:	08 95       	ret

00000fc4 <TWI_stop>:

void TWI_stop(void)
{
     fc4:	df 93       	push	r29
     fc6:	cf 93       	push	r28
     fc8:	cd b7       	in	r28, 0x3d	; 61
     fca:	de b7       	in	r29, 0x3e	; 62
    /*
	 * Clear the TWINT flag before sending the stop bit TWINT=1
	 * send the stop bit by TWSTO=1
	 * Enable TWI Module TWEN=1
	 */
    TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
     fcc:	e6 e5       	ldi	r30, 0x56	; 86
     fce:	f0 e0       	ldi	r31, 0x00	; 0
     fd0:	84 e9       	ldi	r24, 0x94	; 148
     fd2:	80 83       	st	Z, r24
}
     fd4:	cf 91       	pop	r28
     fd6:	df 91       	pop	r29
     fd8:	08 95       	ret

00000fda <TWI_writeByte>:

void TWI_writeByte(uint8 data)
{
     fda:	df 93       	push	r29
     fdc:	cf 93       	push	r28
     fde:	0f 92       	push	r0
     fe0:	cd b7       	in	r28, 0x3d	; 61
     fe2:	de b7       	in	r29, 0x3e	; 62
     fe4:	89 83       	std	Y+1, r24	; 0x01
    /* Put data On TWI data Register */
    TWDR = data;
     fe6:	e3 e2       	ldi	r30, 0x23	; 35
     fe8:	f0 e0       	ldi	r31, 0x00	; 0
     fea:	89 81       	ldd	r24, Y+1	; 0x01
     fec:	80 83       	st	Z, r24
    /*
	 * Clear the TWINT flag before sending the data TWINT=1
	 * Enable TWI Module TWEN=1
	 */
    TWCR = (1 << TWINT) | (1 << TWEN);
     fee:	e6 e5       	ldi	r30, 0x56	; 86
     ff0:	f0 e0       	ldi	r31, 0x00	; 0
     ff2:	84 e8       	ldi	r24, 0x84	; 132
     ff4:	80 83       	st	Z, r24
    /* Wait for TWINT flag set in TWCR Register(data is send successfully) */
    while(BIT_IS_CLEAR(TWCR,TWINT));
     ff6:	e6 e5       	ldi	r30, 0x56	; 86
     ff8:	f0 e0       	ldi	r31, 0x00	; 0
     ffa:	80 81       	ld	r24, Z
     ffc:	88 23       	and	r24, r24
     ffe:	dc f7       	brge	.-10     	; 0xff6 <TWI_writeByte+0x1c>
}
    1000:	0f 90       	pop	r0
    1002:	cf 91       	pop	r28
    1004:	df 91       	pop	r29
    1006:	08 95       	ret

00001008 <TWI_readByteWithACK>:

uint8 TWI_readByteWithACK(void)
{
    1008:	df 93       	push	r29
    100a:	cf 93       	push	r28
    100c:	cd b7       	in	r28, 0x3d	; 61
    100e:	de b7       	in	r29, 0x3e	; 62
	/*
	 * Clear the TWINT flag before reading the data TWINT=1
	 * Enable sending ACK after reading or receiving data TWEA=1
	 * Enable TWI Module TWEN=1
	 */
    TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA);
    1010:	e6 e5       	ldi	r30, 0x56	; 86
    1012:	f0 e0       	ldi	r31, 0x00	; 0
    1014:	84 ec       	ldi	r24, 0xC4	; 196
    1016:	80 83       	st	Z, r24
    /* Wait for TWINT flag set in TWCR Register (data received successfully) */
    while(BIT_IS_CLEAR(TWCR,TWINT));
    1018:	e6 e5       	ldi	r30, 0x56	; 86
    101a:	f0 e0       	ldi	r31, 0x00	; 0
    101c:	80 81       	ld	r24, Z
    101e:	88 23       	and	r24, r24
    1020:	dc f7       	brge	.-10     	; 0x1018 <TWI_readByteWithACK+0x10>
    /* Read Data */
    return TWDR;
    1022:	e3 e2       	ldi	r30, 0x23	; 35
    1024:	f0 e0       	ldi	r31, 0x00	; 0
    1026:	80 81       	ld	r24, Z
}
    1028:	cf 91       	pop	r28
    102a:	df 91       	pop	r29
    102c:	08 95       	ret

0000102e <TWI_readByteWithNACK>:

uint8 TWI_readByteWithNACK(void)
{
    102e:	df 93       	push	r29
    1030:	cf 93       	push	r28
    1032:	cd b7       	in	r28, 0x3d	; 61
    1034:	de b7       	in	r29, 0x3e	; 62
	/*
	 * Clear the TWINT flag before reading the data TWINT=1
	 * Enable TWI Module TWEN=1
	 */
    TWCR = (1 << TWINT) | (1 << TWEN);
    1036:	e6 e5       	ldi	r30, 0x56	; 86
    1038:	f0 e0       	ldi	r31, 0x00	; 0
    103a:	84 e8       	ldi	r24, 0x84	; 132
    103c:	80 83       	st	Z, r24
    /* Wait for TWINT flag set in TWCR Register (data received successfully) */
    while(BIT_IS_CLEAR(TWCR,TWINT));
    103e:	e6 e5       	ldi	r30, 0x56	; 86
    1040:	f0 e0       	ldi	r31, 0x00	; 0
    1042:	80 81       	ld	r24, Z
    1044:	88 23       	and	r24, r24
    1046:	dc f7       	brge	.-10     	; 0x103e <TWI_readByteWithNACK+0x10>
    /* Read Data */
    return TWDR;
    1048:	e3 e2       	ldi	r30, 0x23	; 35
    104a:	f0 e0       	ldi	r31, 0x00	; 0
    104c:	80 81       	ld	r24, Z
}
    104e:	cf 91       	pop	r28
    1050:	df 91       	pop	r29
    1052:	08 95       	ret

00001054 <TWI_getStatus>:

uint8 TWI_getStatus(void)
{
    1054:	df 93       	push	r29
    1056:	cf 93       	push	r28
    1058:	0f 92       	push	r0
    105a:	cd b7       	in	r28, 0x3d	; 61
    105c:	de b7       	in	r29, 0x3e	; 62
    uint8 status;
    /* masking to eliminate first 3 bits and get the last 5 bits (status bits) */
    status = TWSR & 0xF8;
    105e:	e1 e2       	ldi	r30, 0x21	; 33
    1060:	f0 e0       	ldi	r31, 0x00	; 0
    1062:	80 81       	ld	r24, Z
    1064:	88 7f       	andi	r24, 0xF8	; 248
    1066:	89 83       	std	Y+1, r24	; 0x01
    return status;
    1068:	89 81       	ldd	r24, Y+1	; 0x01
}
    106a:	0f 90       	pop	r0
    106c:	cf 91       	pop	r28
    106e:	df 91       	pop	r29
    1070:	08 95       	ret

00001072 <GPIO_setupPinDirection>:
 * Description :
 * Setup the direction of the required pin input/output.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_setupPinDirection(uint8 port_num, uint8 pin_num,
		GPIO_PinDirectionType direction) {
    1072:	df 93       	push	r29
    1074:	cf 93       	push	r28
    1076:	00 d0       	rcall	.+0      	; 0x1078 <GPIO_setupPinDirection+0x6>
    1078:	00 d0       	rcall	.+0      	; 0x107a <GPIO_setupPinDirection+0x8>
    107a:	0f 92       	push	r0
    107c:	cd b7       	in	r28, 0x3d	; 61
    107e:	de b7       	in	r29, 0x3e	; 62
    1080:	89 83       	std	Y+1, r24	; 0x01
    1082:	6a 83       	std	Y+2, r22	; 0x02
    1084:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if ((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS)) {
    1086:	8a 81       	ldd	r24, Y+2	; 0x02
    1088:	88 30       	cpi	r24, 0x08	; 8
    108a:	08 f0       	brcs	.+2      	; 0x108e <GPIO_setupPinDirection+0x1c>
    108c:	d5 c0       	rjmp	.+426    	; 0x1238 <GPIO_setupPinDirection+0x1c6>
    108e:	89 81       	ldd	r24, Y+1	; 0x01
    1090:	84 30       	cpi	r24, 0x04	; 4
    1092:	08 f0       	brcs	.+2      	; 0x1096 <GPIO_setupPinDirection+0x24>
    1094:	d1 c0       	rjmp	.+418    	; 0x1238 <GPIO_setupPinDirection+0x1c6>
		/* Do Nothing */
	} else {
		/* Setup the pin direction as required */
		switch (port_num) {
    1096:	89 81       	ldd	r24, Y+1	; 0x01
    1098:	28 2f       	mov	r18, r24
    109a:	30 e0       	ldi	r19, 0x00	; 0
    109c:	3d 83       	std	Y+5, r19	; 0x05
    109e:	2c 83       	std	Y+4, r18	; 0x04
    10a0:	8c 81       	ldd	r24, Y+4	; 0x04
    10a2:	9d 81       	ldd	r25, Y+5	; 0x05
    10a4:	81 30       	cpi	r24, 0x01	; 1
    10a6:	91 05       	cpc	r25, r1
    10a8:	09 f4       	brne	.+2      	; 0x10ac <GPIO_setupPinDirection+0x3a>
    10aa:	43 c0       	rjmp	.+134    	; 0x1132 <GPIO_setupPinDirection+0xc0>
    10ac:	2c 81       	ldd	r18, Y+4	; 0x04
    10ae:	3d 81       	ldd	r19, Y+5	; 0x05
    10b0:	22 30       	cpi	r18, 0x02	; 2
    10b2:	31 05       	cpc	r19, r1
    10b4:	2c f4       	brge	.+10     	; 0x10c0 <GPIO_setupPinDirection+0x4e>
    10b6:	8c 81       	ldd	r24, Y+4	; 0x04
    10b8:	9d 81       	ldd	r25, Y+5	; 0x05
    10ba:	00 97       	sbiw	r24, 0x00	; 0
    10bc:	71 f0       	breq	.+28     	; 0x10da <GPIO_setupPinDirection+0x68>
    10be:	bc c0       	rjmp	.+376    	; 0x1238 <GPIO_setupPinDirection+0x1c6>
    10c0:	2c 81       	ldd	r18, Y+4	; 0x04
    10c2:	3d 81       	ldd	r19, Y+5	; 0x05
    10c4:	22 30       	cpi	r18, 0x02	; 2
    10c6:	31 05       	cpc	r19, r1
    10c8:	09 f4       	brne	.+2      	; 0x10cc <GPIO_setupPinDirection+0x5a>
    10ca:	5f c0       	rjmp	.+190    	; 0x118a <GPIO_setupPinDirection+0x118>
    10cc:	8c 81       	ldd	r24, Y+4	; 0x04
    10ce:	9d 81       	ldd	r25, Y+5	; 0x05
    10d0:	83 30       	cpi	r24, 0x03	; 3
    10d2:	91 05       	cpc	r25, r1
    10d4:	09 f4       	brne	.+2      	; 0x10d8 <GPIO_setupPinDirection+0x66>
    10d6:	85 c0       	rjmp	.+266    	; 0x11e2 <GPIO_setupPinDirection+0x170>
    10d8:	af c0       	rjmp	.+350    	; 0x1238 <GPIO_setupPinDirection+0x1c6>
		case PORTA_ID:
			if (direction == PIN_OUTPUT) {
    10da:	8b 81       	ldd	r24, Y+3	; 0x03
    10dc:	81 30       	cpi	r24, 0x01	; 1
    10de:	a1 f4       	brne	.+40     	; 0x1108 <GPIO_setupPinDirection+0x96>

				SET_BIT(DDRA, pin_num); /* This line is equivalent to 	DDRA |= (1 << pin_num);  */
    10e0:	aa e3       	ldi	r26, 0x3A	; 58
    10e2:	b0 e0       	ldi	r27, 0x00	; 0
    10e4:	ea e3       	ldi	r30, 0x3A	; 58
    10e6:	f0 e0       	ldi	r31, 0x00	; 0
    10e8:	80 81       	ld	r24, Z
    10ea:	48 2f       	mov	r20, r24
    10ec:	8a 81       	ldd	r24, Y+2	; 0x02
    10ee:	28 2f       	mov	r18, r24
    10f0:	30 e0       	ldi	r19, 0x00	; 0
    10f2:	81 e0       	ldi	r24, 0x01	; 1
    10f4:	90 e0       	ldi	r25, 0x00	; 0
    10f6:	02 2e       	mov	r0, r18
    10f8:	02 c0       	rjmp	.+4      	; 0x10fe <GPIO_setupPinDirection+0x8c>
    10fa:	88 0f       	add	r24, r24
    10fc:	99 1f       	adc	r25, r25
    10fe:	0a 94       	dec	r0
    1100:	e2 f7       	brpl	.-8      	; 0x10fa <GPIO_setupPinDirection+0x88>
    1102:	84 2b       	or	r24, r20
    1104:	8c 93       	st	X, r24
    1106:	98 c0       	rjmp	.+304    	; 0x1238 <GPIO_setupPinDirection+0x1c6>
			} else {
				CLEAR_BIT(DDRA, pin_num); /* This line is equivalent to 	DDRA &= ~(1 << pin_num); */
    1108:	aa e3       	ldi	r26, 0x3A	; 58
    110a:	b0 e0       	ldi	r27, 0x00	; 0
    110c:	ea e3       	ldi	r30, 0x3A	; 58
    110e:	f0 e0       	ldi	r31, 0x00	; 0
    1110:	80 81       	ld	r24, Z
    1112:	48 2f       	mov	r20, r24
    1114:	8a 81       	ldd	r24, Y+2	; 0x02
    1116:	28 2f       	mov	r18, r24
    1118:	30 e0       	ldi	r19, 0x00	; 0
    111a:	81 e0       	ldi	r24, 0x01	; 1
    111c:	90 e0       	ldi	r25, 0x00	; 0
    111e:	02 2e       	mov	r0, r18
    1120:	02 c0       	rjmp	.+4      	; 0x1126 <GPIO_setupPinDirection+0xb4>
    1122:	88 0f       	add	r24, r24
    1124:	99 1f       	adc	r25, r25
    1126:	0a 94       	dec	r0
    1128:	e2 f7       	brpl	.-8      	; 0x1122 <GPIO_setupPinDirection+0xb0>
    112a:	80 95       	com	r24
    112c:	84 23       	and	r24, r20
    112e:	8c 93       	st	X, r24
    1130:	83 c0       	rjmp	.+262    	; 0x1238 <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTB_ID:
			if (direction == PIN_OUTPUT) {
    1132:	8b 81       	ldd	r24, Y+3	; 0x03
    1134:	81 30       	cpi	r24, 0x01	; 1
    1136:	a1 f4       	brne	.+40     	; 0x1160 <GPIO_setupPinDirection+0xee>
				SET_BIT(DDRB, pin_num);
    1138:	a7 e3       	ldi	r26, 0x37	; 55
    113a:	b0 e0       	ldi	r27, 0x00	; 0
    113c:	e7 e3       	ldi	r30, 0x37	; 55
    113e:	f0 e0       	ldi	r31, 0x00	; 0
    1140:	80 81       	ld	r24, Z
    1142:	48 2f       	mov	r20, r24
    1144:	8a 81       	ldd	r24, Y+2	; 0x02
    1146:	28 2f       	mov	r18, r24
    1148:	30 e0       	ldi	r19, 0x00	; 0
    114a:	81 e0       	ldi	r24, 0x01	; 1
    114c:	90 e0       	ldi	r25, 0x00	; 0
    114e:	02 2e       	mov	r0, r18
    1150:	02 c0       	rjmp	.+4      	; 0x1156 <GPIO_setupPinDirection+0xe4>
    1152:	88 0f       	add	r24, r24
    1154:	99 1f       	adc	r25, r25
    1156:	0a 94       	dec	r0
    1158:	e2 f7       	brpl	.-8      	; 0x1152 <GPIO_setupPinDirection+0xe0>
    115a:	84 2b       	or	r24, r20
    115c:	8c 93       	st	X, r24
    115e:	6c c0       	rjmp	.+216    	; 0x1238 <GPIO_setupPinDirection+0x1c6>
			} else {
				CLEAR_BIT(DDRB, pin_num);
    1160:	a7 e3       	ldi	r26, 0x37	; 55
    1162:	b0 e0       	ldi	r27, 0x00	; 0
    1164:	e7 e3       	ldi	r30, 0x37	; 55
    1166:	f0 e0       	ldi	r31, 0x00	; 0
    1168:	80 81       	ld	r24, Z
    116a:	48 2f       	mov	r20, r24
    116c:	8a 81       	ldd	r24, Y+2	; 0x02
    116e:	28 2f       	mov	r18, r24
    1170:	30 e0       	ldi	r19, 0x00	; 0
    1172:	81 e0       	ldi	r24, 0x01	; 1
    1174:	90 e0       	ldi	r25, 0x00	; 0
    1176:	02 2e       	mov	r0, r18
    1178:	02 c0       	rjmp	.+4      	; 0x117e <GPIO_setupPinDirection+0x10c>
    117a:	88 0f       	add	r24, r24
    117c:	99 1f       	adc	r25, r25
    117e:	0a 94       	dec	r0
    1180:	e2 f7       	brpl	.-8      	; 0x117a <GPIO_setupPinDirection+0x108>
    1182:	80 95       	com	r24
    1184:	84 23       	and	r24, r20
    1186:	8c 93       	st	X, r24
    1188:	57 c0       	rjmp	.+174    	; 0x1238 <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTC_ID:
			if (direction == PIN_OUTPUT) {
    118a:	8b 81       	ldd	r24, Y+3	; 0x03
    118c:	81 30       	cpi	r24, 0x01	; 1
    118e:	a1 f4       	brne	.+40     	; 0x11b8 <GPIO_setupPinDirection+0x146>
				SET_BIT(DDRC, pin_num);
    1190:	a4 e3       	ldi	r26, 0x34	; 52
    1192:	b0 e0       	ldi	r27, 0x00	; 0
    1194:	e4 e3       	ldi	r30, 0x34	; 52
    1196:	f0 e0       	ldi	r31, 0x00	; 0
    1198:	80 81       	ld	r24, Z
    119a:	48 2f       	mov	r20, r24
    119c:	8a 81       	ldd	r24, Y+2	; 0x02
    119e:	28 2f       	mov	r18, r24
    11a0:	30 e0       	ldi	r19, 0x00	; 0
    11a2:	81 e0       	ldi	r24, 0x01	; 1
    11a4:	90 e0       	ldi	r25, 0x00	; 0
    11a6:	02 2e       	mov	r0, r18
    11a8:	02 c0       	rjmp	.+4      	; 0x11ae <GPIO_setupPinDirection+0x13c>
    11aa:	88 0f       	add	r24, r24
    11ac:	99 1f       	adc	r25, r25
    11ae:	0a 94       	dec	r0
    11b0:	e2 f7       	brpl	.-8      	; 0x11aa <GPIO_setupPinDirection+0x138>
    11b2:	84 2b       	or	r24, r20
    11b4:	8c 93       	st	X, r24
    11b6:	40 c0       	rjmp	.+128    	; 0x1238 <GPIO_setupPinDirection+0x1c6>
			} else {
				CLEAR_BIT(DDRC, pin_num);
    11b8:	a4 e3       	ldi	r26, 0x34	; 52
    11ba:	b0 e0       	ldi	r27, 0x00	; 0
    11bc:	e4 e3       	ldi	r30, 0x34	; 52
    11be:	f0 e0       	ldi	r31, 0x00	; 0
    11c0:	80 81       	ld	r24, Z
    11c2:	48 2f       	mov	r20, r24
    11c4:	8a 81       	ldd	r24, Y+2	; 0x02
    11c6:	28 2f       	mov	r18, r24
    11c8:	30 e0       	ldi	r19, 0x00	; 0
    11ca:	81 e0       	ldi	r24, 0x01	; 1
    11cc:	90 e0       	ldi	r25, 0x00	; 0
    11ce:	02 2e       	mov	r0, r18
    11d0:	02 c0       	rjmp	.+4      	; 0x11d6 <GPIO_setupPinDirection+0x164>
    11d2:	88 0f       	add	r24, r24
    11d4:	99 1f       	adc	r25, r25
    11d6:	0a 94       	dec	r0
    11d8:	e2 f7       	brpl	.-8      	; 0x11d2 <GPIO_setupPinDirection+0x160>
    11da:	80 95       	com	r24
    11dc:	84 23       	and	r24, r20
    11de:	8c 93       	st	X, r24
    11e0:	2b c0       	rjmp	.+86     	; 0x1238 <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTD_ID:
			if (direction == PIN_OUTPUT) {
    11e2:	8b 81       	ldd	r24, Y+3	; 0x03
    11e4:	81 30       	cpi	r24, 0x01	; 1
    11e6:	a1 f4       	brne	.+40     	; 0x1210 <GPIO_setupPinDirection+0x19e>
				SET_BIT(DDRD, pin_num);
    11e8:	a1 e3       	ldi	r26, 0x31	; 49
    11ea:	b0 e0       	ldi	r27, 0x00	; 0
    11ec:	e1 e3       	ldi	r30, 0x31	; 49
    11ee:	f0 e0       	ldi	r31, 0x00	; 0
    11f0:	80 81       	ld	r24, Z
    11f2:	48 2f       	mov	r20, r24
    11f4:	8a 81       	ldd	r24, Y+2	; 0x02
    11f6:	28 2f       	mov	r18, r24
    11f8:	30 e0       	ldi	r19, 0x00	; 0
    11fa:	81 e0       	ldi	r24, 0x01	; 1
    11fc:	90 e0       	ldi	r25, 0x00	; 0
    11fe:	02 2e       	mov	r0, r18
    1200:	02 c0       	rjmp	.+4      	; 0x1206 <GPIO_setupPinDirection+0x194>
    1202:	88 0f       	add	r24, r24
    1204:	99 1f       	adc	r25, r25
    1206:	0a 94       	dec	r0
    1208:	e2 f7       	brpl	.-8      	; 0x1202 <GPIO_setupPinDirection+0x190>
    120a:	84 2b       	or	r24, r20
    120c:	8c 93       	st	X, r24
    120e:	14 c0       	rjmp	.+40     	; 0x1238 <GPIO_setupPinDirection+0x1c6>
			} else {
				CLEAR_BIT(DDRD, pin_num);
    1210:	a1 e3       	ldi	r26, 0x31	; 49
    1212:	b0 e0       	ldi	r27, 0x00	; 0
    1214:	e1 e3       	ldi	r30, 0x31	; 49
    1216:	f0 e0       	ldi	r31, 0x00	; 0
    1218:	80 81       	ld	r24, Z
    121a:	48 2f       	mov	r20, r24
    121c:	8a 81       	ldd	r24, Y+2	; 0x02
    121e:	28 2f       	mov	r18, r24
    1220:	30 e0       	ldi	r19, 0x00	; 0
    1222:	81 e0       	ldi	r24, 0x01	; 1
    1224:	90 e0       	ldi	r25, 0x00	; 0
    1226:	02 2e       	mov	r0, r18
    1228:	02 c0       	rjmp	.+4      	; 0x122e <GPIO_setupPinDirection+0x1bc>
    122a:	88 0f       	add	r24, r24
    122c:	99 1f       	adc	r25, r25
    122e:	0a 94       	dec	r0
    1230:	e2 f7       	brpl	.-8      	; 0x122a <GPIO_setupPinDirection+0x1b8>
    1232:	80 95       	com	r24
    1234:	84 23       	and	r24, r20
    1236:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    1238:	0f 90       	pop	r0
    123a:	0f 90       	pop	r0
    123c:	0f 90       	pop	r0
    123e:	0f 90       	pop	r0
    1240:	0f 90       	pop	r0
    1242:	cf 91       	pop	r28
    1244:	df 91       	pop	r29
    1246:	08 95       	ret

00001248 <GPIO_writePin>:
 * Description :
 * Write the value Logic High or Logic Low on the required pin.
 * If the input port number or pin number are not correct, The function will not handle the request.
 * If the pin is input, this function will enable/disable the internal pull-up resistor.
 */
void GPIO_writePin(uint8 port_num, uint8 pin_num, uint8 value) {
    1248:	df 93       	push	r29
    124a:	cf 93       	push	r28
    124c:	00 d0       	rcall	.+0      	; 0x124e <GPIO_writePin+0x6>
    124e:	00 d0       	rcall	.+0      	; 0x1250 <GPIO_writePin+0x8>
    1250:	0f 92       	push	r0
    1252:	cd b7       	in	r28, 0x3d	; 61
    1254:	de b7       	in	r29, 0x3e	; 62
    1256:	89 83       	std	Y+1, r24	; 0x01
    1258:	6a 83       	std	Y+2, r22	; 0x02
    125a:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if ((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS)) {
    125c:	8a 81       	ldd	r24, Y+2	; 0x02
    125e:	88 30       	cpi	r24, 0x08	; 8
    1260:	08 f0       	brcs	.+2      	; 0x1264 <GPIO_writePin+0x1c>
    1262:	d5 c0       	rjmp	.+426    	; 0x140e <GPIO_writePin+0x1c6>
    1264:	89 81       	ldd	r24, Y+1	; 0x01
    1266:	84 30       	cpi	r24, 0x04	; 4
    1268:	08 f0       	brcs	.+2      	; 0x126c <GPIO_writePin+0x24>
    126a:	d1 c0       	rjmp	.+418    	; 0x140e <GPIO_writePin+0x1c6>
		/* Do Nothing */
	} else {
		/* Write the pin value as required */
		switch (port_num) {
    126c:	89 81       	ldd	r24, Y+1	; 0x01
    126e:	28 2f       	mov	r18, r24
    1270:	30 e0       	ldi	r19, 0x00	; 0
    1272:	3d 83       	std	Y+5, r19	; 0x05
    1274:	2c 83       	std	Y+4, r18	; 0x04
    1276:	8c 81       	ldd	r24, Y+4	; 0x04
    1278:	9d 81       	ldd	r25, Y+5	; 0x05
    127a:	81 30       	cpi	r24, 0x01	; 1
    127c:	91 05       	cpc	r25, r1
    127e:	09 f4       	brne	.+2      	; 0x1282 <GPIO_writePin+0x3a>
    1280:	43 c0       	rjmp	.+134    	; 0x1308 <GPIO_writePin+0xc0>
    1282:	2c 81       	ldd	r18, Y+4	; 0x04
    1284:	3d 81       	ldd	r19, Y+5	; 0x05
    1286:	22 30       	cpi	r18, 0x02	; 2
    1288:	31 05       	cpc	r19, r1
    128a:	2c f4       	brge	.+10     	; 0x1296 <GPIO_writePin+0x4e>
    128c:	8c 81       	ldd	r24, Y+4	; 0x04
    128e:	9d 81       	ldd	r25, Y+5	; 0x05
    1290:	00 97       	sbiw	r24, 0x00	; 0
    1292:	71 f0       	breq	.+28     	; 0x12b0 <GPIO_writePin+0x68>
    1294:	bc c0       	rjmp	.+376    	; 0x140e <GPIO_writePin+0x1c6>
    1296:	2c 81       	ldd	r18, Y+4	; 0x04
    1298:	3d 81       	ldd	r19, Y+5	; 0x05
    129a:	22 30       	cpi	r18, 0x02	; 2
    129c:	31 05       	cpc	r19, r1
    129e:	09 f4       	brne	.+2      	; 0x12a2 <GPIO_writePin+0x5a>
    12a0:	5f c0       	rjmp	.+190    	; 0x1360 <GPIO_writePin+0x118>
    12a2:	8c 81       	ldd	r24, Y+4	; 0x04
    12a4:	9d 81       	ldd	r25, Y+5	; 0x05
    12a6:	83 30       	cpi	r24, 0x03	; 3
    12a8:	91 05       	cpc	r25, r1
    12aa:	09 f4       	brne	.+2      	; 0x12ae <GPIO_writePin+0x66>
    12ac:	85 c0       	rjmp	.+266    	; 0x13b8 <GPIO_writePin+0x170>
    12ae:	af c0       	rjmp	.+350    	; 0x140e <GPIO_writePin+0x1c6>
		case PORTA_ID:
			if (value == LOGIC_HIGH) {
    12b0:	8b 81       	ldd	r24, Y+3	; 0x03
    12b2:	81 30       	cpi	r24, 0x01	; 1
    12b4:	a1 f4       	brne	.+40     	; 0x12de <GPIO_writePin+0x96>
				SET_BIT(PORTA, pin_num);
    12b6:	ab e3       	ldi	r26, 0x3B	; 59
    12b8:	b0 e0       	ldi	r27, 0x00	; 0
    12ba:	eb e3       	ldi	r30, 0x3B	; 59
    12bc:	f0 e0       	ldi	r31, 0x00	; 0
    12be:	80 81       	ld	r24, Z
    12c0:	48 2f       	mov	r20, r24
    12c2:	8a 81       	ldd	r24, Y+2	; 0x02
    12c4:	28 2f       	mov	r18, r24
    12c6:	30 e0       	ldi	r19, 0x00	; 0
    12c8:	81 e0       	ldi	r24, 0x01	; 1
    12ca:	90 e0       	ldi	r25, 0x00	; 0
    12cc:	02 2e       	mov	r0, r18
    12ce:	02 c0       	rjmp	.+4      	; 0x12d4 <GPIO_writePin+0x8c>
    12d0:	88 0f       	add	r24, r24
    12d2:	99 1f       	adc	r25, r25
    12d4:	0a 94       	dec	r0
    12d6:	e2 f7       	brpl	.-8      	; 0x12d0 <GPIO_writePin+0x88>
    12d8:	84 2b       	or	r24, r20
    12da:	8c 93       	st	X, r24
    12dc:	98 c0       	rjmp	.+304    	; 0x140e <GPIO_writePin+0x1c6>
			} else {
				CLEAR_BIT(PORTA, pin_num);
    12de:	ab e3       	ldi	r26, 0x3B	; 59
    12e0:	b0 e0       	ldi	r27, 0x00	; 0
    12e2:	eb e3       	ldi	r30, 0x3B	; 59
    12e4:	f0 e0       	ldi	r31, 0x00	; 0
    12e6:	80 81       	ld	r24, Z
    12e8:	48 2f       	mov	r20, r24
    12ea:	8a 81       	ldd	r24, Y+2	; 0x02
    12ec:	28 2f       	mov	r18, r24
    12ee:	30 e0       	ldi	r19, 0x00	; 0
    12f0:	81 e0       	ldi	r24, 0x01	; 1
    12f2:	90 e0       	ldi	r25, 0x00	; 0
    12f4:	02 2e       	mov	r0, r18
    12f6:	02 c0       	rjmp	.+4      	; 0x12fc <GPIO_writePin+0xb4>
    12f8:	88 0f       	add	r24, r24
    12fa:	99 1f       	adc	r25, r25
    12fc:	0a 94       	dec	r0
    12fe:	e2 f7       	brpl	.-8      	; 0x12f8 <GPIO_writePin+0xb0>
    1300:	80 95       	com	r24
    1302:	84 23       	and	r24, r20
    1304:	8c 93       	st	X, r24
    1306:	83 c0       	rjmp	.+262    	; 0x140e <GPIO_writePin+0x1c6>
			}
			break;
		case PORTB_ID:
			if (value == LOGIC_HIGH) {
    1308:	8b 81       	ldd	r24, Y+3	; 0x03
    130a:	81 30       	cpi	r24, 0x01	; 1
    130c:	a1 f4       	brne	.+40     	; 0x1336 <GPIO_writePin+0xee>
				SET_BIT(PORTB, pin_num);
    130e:	a8 e3       	ldi	r26, 0x38	; 56
    1310:	b0 e0       	ldi	r27, 0x00	; 0
    1312:	e8 e3       	ldi	r30, 0x38	; 56
    1314:	f0 e0       	ldi	r31, 0x00	; 0
    1316:	80 81       	ld	r24, Z
    1318:	48 2f       	mov	r20, r24
    131a:	8a 81       	ldd	r24, Y+2	; 0x02
    131c:	28 2f       	mov	r18, r24
    131e:	30 e0       	ldi	r19, 0x00	; 0
    1320:	81 e0       	ldi	r24, 0x01	; 1
    1322:	90 e0       	ldi	r25, 0x00	; 0
    1324:	02 2e       	mov	r0, r18
    1326:	02 c0       	rjmp	.+4      	; 0x132c <GPIO_writePin+0xe4>
    1328:	88 0f       	add	r24, r24
    132a:	99 1f       	adc	r25, r25
    132c:	0a 94       	dec	r0
    132e:	e2 f7       	brpl	.-8      	; 0x1328 <GPIO_writePin+0xe0>
    1330:	84 2b       	or	r24, r20
    1332:	8c 93       	st	X, r24
    1334:	6c c0       	rjmp	.+216    	; 0x140e <GPIO_writePin+0x1c6>
			} else {
				CLEAR_BIT(PORTB, pin_num);
    1336:	a8 e3       	ldi	r26, 0x38	; 56
    1338:	b0 e0       	ldi	r27, 0x00	; 0
    133a:	e8 e3       	ldi	r30, 0x38	; 56
    133c:	f0 e0       	ldi	r31, 0x00	; 0
    133e:	80 81       	ld	r24, Z
    1340:	48 2f       	mov	r20, r24
    1342:	8a 81       	ldd	r24, Y+2	; 0x02
    1344:	28 2f       	mov	r18, r24
    1346:	30 e0       	ldi	r19, 0x00	; 0
    1348:	81 e0       	ldi	r24, 0x01	; 1
    134a:	90 e0       	ldi	r25, 0x00	; 0
    134c:	02 2e       	mov	r0, r18
    134e:	02 c0       	rjmp	.+4      	; 0x1354 <GPIO_writePin+0x10c>
    1350:	88 0f       	add	r24, r24
    1352:	99 1f       	adc	r25, r25
    1354:	0a 94       	dec	r0
    1356:	e2 f7       	brpl	.-8      	; 0x1350 <GPIO_writePin+0x108>
    1358:	80 95       	com	r24
    135a:	84 23       	and	r24, r20
    135c:	8c 93       	st	X, r24
    135e:	57 c0       	rjmp	.+174    	; 0x140e <GPIO_writePin+0x1c6>
			}
			break;
		case PORTC_ID:
			if (value == LOGIC_HIGH) {
    1360:	8b 81       	ldd	r24, Y+3	; 0x03
    1362:	81 30       	cpi	r24, 0x01	; 1
    1364:	a1 f4       	brne	.+40     	; 0x138e <GPIO_writePin+0x146>
				SET_BIT(PORTC, pin_num);
    1366:	a5 e3       	ldi	r26, 0x35	; 53
    1368:	b0 e0       	ldi	r27, 0x00	; 0
    136a:	e5 e3       	ldi	r30, 0x35	; 53
    136c:	f0 e0       	ldi	r31, 0x00	; 0
    136e:	80 81       	ld	r24, Z
    1370:	48 2f       	mov	r20, r24
    1372:	8a 81       	ldd	r24, Y+2	; 0x02
    1374:	28 2f       	mov	r18, r24
    1376:	30 e0       	ldi	r19, 0x00	; 0
    1378:	81 e0       	ldi	r24, 0x01	; 1
    137a:	90 e0       	ldi	r25, 0x00	; 0
    137c:	02 2e       	mov	r0, r18
    137e:	02 c0       	rjmp	.+4      	; 0x1384 <GPIO_writePin+0x13c>
    1380:	88 0f       	add	r24, r24
    1382:	99 1f       	adc	r25, r25
    1384:	0a 94       	dec	r0
    1386:	e2 f7       	brpl	.-8      	; 0x1380 <GPIO_writePin+0x138>
    1388:	84 2b       	or	r24, r20
    138a:	8c 93       	st	X, r24
    138c:	40 c0       	rjmp	.+128    	; 0x140e <GPIO_writePin+0x1c6>
			} else {
				CLEAR_BIT(PORTC, pin_num);
    138e:	a5 e3       	ldi	r26, 0x35	; 53
    1390:	b0 e0       	ldi	r27, 0x00	; 0
    1392:	e5 e3       	ldi	r30, 0x35	; 53
    1394:	f0 e0       	ldi	r31, 0x00	; 0
    1396:	80 81       	ld	r24, Z
    1398:	48 2f       	mov	r20, r24
    139a:	8a 81       	ldd	r24, Y+2	; 0x02
    139c:	28 2f       	mov	r18, r24
    139e:	30 e0       	ldi	r19, 0x00	; 0
    13a0:	81 e0       	ldi	r24, 0x01	; 1
    13a2:	90 e0       	ldi	r25, 0x00	; 0
    13a4:	02 2e       	mov	r0, r18
    13a6:	02 c0       	rjmp	.+4      	; 0x13ac <GPIO_writePin+0x164>
    13a8:	88 0f       	add	r24, r24
    13aa:	99 1f       	adc	r25, r25
    13ac:	0a 94       	dec	r0
    13ae:	e2 f7       	brpl	.-8      	; 0x13a8 <GPIO_writePin+0x160>
    13b0:	80 95       	com	r24
    13b2:	84 23       	and	r24, r20
    13b4:	8c 93       	st	X, r24
    13b6:	2b c0       	rjmp	.+86     	; 0x140e <GPIO_writePin+0x1c6>
			}
			break;
		case PORTD_ID:
			if (value == LOGIC_HIGH) {
    13b8:	8b 81       	ldd	r24, Y+3	; 0x03
    13ba:	81 30       	cpi	r24, 0x01	; 1
    13bc:	a1 f4       	brne	.+40     	; 0x13e6 <GPIO_writePin+0x19e>
				SET_BIT(PORTD, pin_num);
    13be:	a2 e3       	ldi	r26, 0x32	; 50
    13c0:	b0 e0       	ldi	r27, 0x00	; 0
    13c2:	e2 e3       	ldi	r30, 0x32	; 50
    13c4:	f0 e0       	ldi	r31, 0x00	; 0
    13c6:	80 81       	ld	r24, Z
    13c8:	48 2f       	mov	r20, r24
    13ca:	8a 81       	ldd	r24, Y+2	; 0x02
    13cc:	28 2f       	mov	r18, r24
    13ce:	30 e0       	ldi	r19, 0x00	; 0
    13d0:	81 e0       	ldi	r24, 0x01	; 1
    13d2:	90 e0       	ldi	r25, 0x00	; 0
    13d4:	02 2e       	mov	r0, r18
    13d6:	02 c0       	rjmp	.+4      	; 0x13dc <GPIO_writePin+0x194>
    13d8:	88 0f       	add	r24, r24
    13da:	99 1f       	adc	r25, r25
    13dc:	0a 94       	dec	r0
    13de:	e2 f7       	brpl	.-8      	; 0x13d8 <GPIO_writePin+0x190>
    13e0:	84 2b       	or	r24, r20
    13e2:	8c 93       	st	X, r24
    13e4:	14 c0       	rjmp	.+40     	; 0x140e <GPIO_writePin+0x1c6>
			} else {
				CLEAR_BIT(PORTD, pin_num);
    13e6:	a2 e3       	ldi	r26, 0x32	; 50
    13e8:	b0 e0       	ldi	r27, 0x00	; 0
    13ea:	e2 e3       	ldi	r30, 0x32	; 50
    13ec:	f0 e0       	ldi	r31, 0x00	; 0
    13ee:	80 81       	ld	r24, Z
    13f0:	48 2f       	mov	r20, r24
    13f2:	8a 81       	ldd	r24, Y+2	; 0x02
    13f4:	28 2f       	mov	r18, r24
    13f6:	30 e0       	ldi	r19, 0x00	; 0
    13f8:	81 e0       	ldi	r24, 0x01	; 1
    13fa:	90 e0       	ldi	r25, 0x00	; 0
    13fc:	02 2e       	mov	r0, r18
    13fe:	02 c0       	rjmp	.+4      	; 0x1404 <GPIO_writePin+0x1bc>
    1400:	88 0f       	add	r24, r24
    1402:	99 1f       	adc	r25, r25
    1404:	0a 94       	dec	r0
    1406:	e2 f7       	brpl	.-8      	; 0x1400 <GPIO_writePin+0x1b8>
    1408:	80 95       	com	r24
    140a:	84 23       	and	r24, r20
    140c:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    140e:	0f 90       	pop	r0
    1410:	0f 90       	pop	r0
    1412:	0f 90       	pop	r0
    1414:	0f 90       	pop	r0
    1416:	0f 90       	pop	r0
    1418:	cf 91       	pop	r28
    141a:	df 91       	pop	r29
    141c:	08 95       	ret

0000141e <GPIO_readPin>:
/*
 * Description :
 * Read and return the value for the required pin, it should be Logic High or Logic Low.
 * If the input port number or pin number are not correct, The function will return Logic Low.
 */
uint8 GPIO_readPin(uint8 port_num, uint8 pin_num) {
    141e:	df 93       	push	r29
    1420:	cf 93       	push	r28
    1422:	00 d0       	rcall	.+0      	; 0x1424 <GPIO_readPin+0x6>
    1424:	00 d0       	rcall	.+0      	; 0x1426 <GPIO_readPin+0x8>
    1426:	0f 92       	push	r0
    1428:	cd b7       	in	r28, 0x3d	; 61
    142a:	de b7       	in	r29, 0x3e	; 62
    142c:	8a 83       	std	Y+2, r24	; 0x02
    142e:	6b 83       	std	Y+3, r22	; 0x03
	uint8 pin_value = LOGIC_LOW;
    1430:	19 82       	std	Y+1, r1	; 0x01
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if ((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS)) {
    1432:	8b 81       	ldd	r24, Y+3	; 0x03
    1434:	88 30       	cpi	r24, 0x08	; 8
    1436:	08 f0       	brcs	.+2      	; 0x143a <GPIO_readPin+0x1c>
    1438:	84 c0       	rjmp	.+264    	; 0x1542 <GPIO_readPin+0x124>
    143a:	8a 81       	ldd	r24, Y+2	; 0x02
    143c:	84 30       	cpi	r24, 0x04	; 4
    143e:	08 f0       	brcs	.+2      	; 0x1442 <GPIO_readPin+0x24>
    1440:	80 c0       	rjmp	.+256    	; 0x1542 <GPIO_readPin+0x124>
		/* Do Nothing */
	} else {
		/* Read the pin value as required */
		switch (port_num) {
    1442:	8a 81       	ldd	r24, Y+2	; 0x02
    1444:	28 2f       	mov	r18, r24
    1446:	30 e0       	ldi	r19, 0x00	; 0
    1448:	3d 83       	std	Y+5, r19	; 0x05
    144a:	2c 83       	std	Y+4, r18	; 0x04
    144c:	4c 81       	ldd	r20, Y+4	; 0x04
    144e:	5d 81       	ldd	r21, Y+5	; 0x05
    1450:	41 30       	cpi	r20, 0x01	; 1
    1452:	51 05       	cpc	r21, r1
    1454:	79 f1       	breq	.+94     	; 0x14b4 <GPIO_readPin+0x96>
    1456:	8c 81       	ldd	r24, Y+4	; 0x04
    1458:	9d 81       	ldd	r25, Y+5	; 0x05
    145a:	82 30       	cpi	r24, 0x02	; 2
    145c:	91 05       	cpc	r25, r1
    145e:	34 f4       	brge	.+12     	; 0x146c <GPIO_readPin+0x4e>
    1460:	2c 81       	ldd	r18, Y+4	; 0x04
    1462:	3d 81       	ldd	r19, Y+5	; 0x05
    1464:	21 15       	cp	r18, r1
    1466:	31 05       	cpc	r19, r1
    1468:	69 f0       	breq	.+26     	; 0x1484 <GPIO_readPin+0x66>
    146a:	6b c0       	rjmp	.+214    	; 0x1542 <GPIO_readPin+0x124>
    146c:	4c 81       	ldd	r20, Y+4	; 0x04
    146e:	5d 81       	ldd	r21, Y+5	; 0x05
    1470:	42 30       	cpi	r20, 0x02	; 2
    1472:	51 05       	cpc	r21, r1
    1474:	b9 f1       	breq	.+110    	; 0x14e4 <GPIO_readPin+0xc6>
    1476:	8c 81       	ldd	r24, Y+4	; 0x04
    1478:	9d 81       	ldd	r25, Y+5	; 0x05
    147a:	83 30       	cpi	r24, 0x03	; 3
    147c:	91 05       	cpc	r25, r1
    147e:	09 f4       	brne	.+2      	; 0x1482 <GPIO_readPin+0x64>
    1480:	49 c0       	rjmp	.+146    	; 0x1514 <GPIO_readPin+0xf6>
    1482:	5f c0       	rjmp	.+190    	; 0x1542 <GPIO_readPin+0x124>
		case PORTA_ID:
			if (BIT_IS_SET(PINA, pin_num)) {
    1484:	e9 e3       	ldi	r30, 0x39	; 57
    1486:	f0 e0       	ldi	r31, 0x00	; 0
    1488:	80 81       	ld	r24, Z
    148a:	28 2f       	mov	r18, r24
    148c:	30 e0       	ldi	r19, 0x00	; 0
    148e:	8b 81       	ldd	r24, Y+3	; 0x03
    1490:	88 2f       	mov	r24, r24
    1492:	90 e0       	ldi	r25, 0x00	; 0
    1494:	a9 01       	movw	r20, r18
    1496:	02 c0       	rjmp	.+4      	; 0x149c <GPIO_readPin+0x7e>
    1498:	55 95       	asr	r21
    149a:	47 95       	ror	r20
    149c:	8a 95       	dec	r24
    149e:	e2 f7       	brpl	.-8      	; 0x1498 <GPIO_readPin+0x7a>
    14a0:	ca 01       	movw	r24, r20
    14a2:	81 70       	andi	r24, 0x01	; 1
    14a4:	90 70       	andi	r25, 0x00	; 0
    14a6:	88 23       	and	r24, r24
    14a8:	19 f0       	breq	.+6      	; 0x14b0 <GPIO_readPin+0x92>
				pin_value = LOGIC_HIGH;
    14aa:	81 e0       	ldi	r24, 0x01	; 1
    14ac:	89 83       	std	Y+1, r24	; 0x01
    14ae:	49 c0       	rjmp	.+146    	; 0x1542 <GPIO_readPin+0x124>
			} else {
				pin_value = LOGIC_LOW;
    14b0:	19 82       	std	Y+1, r1	; 0x01
    14b2:	47 c0       	rjmp	.+142    	; 0x1542 <GPIO_readPin+0x124>
			}
			break;
		case PORTB_ID:
			if (BIT_IS_SET(PINB, pin_num)) {
    14b4:	e6 e3       	ldi	r30, 0x36	; 54
    14b6:	f0 e0       	ldi	r31, 0x00	; 0
    14b8:	80 81       	ld	r24, Z
    14ba:	28 2f       	mov	r18, r24
    14bc:	30 e0       	ldi	r19, 0x00	; 0
    14be:	8b 81       	ldd	r24, Y+3	; 0x03
    14c0:	88 2f       	mov	r24, r24
    14c2:	90 e0       	ldi	r25, 0x00	; 0
    14c4:	a9 01       	movw	r20, r18
    14c6:	02 c0       	rjmp	.+4      	; 0x14cc <GPIO_readPin+0xae>
    14c8:	55 95       	asr	r21
    14ca:	47 95       	ror	r20
    14cc:	8a 95       	dec	r24
    14ce:	e2 f7       	brpl	.-8      	; 0x14c8 <GPIO_readPin+0xaa>
    14d0:	ca 01       	movw	r24, r20
    14d2:	81 70       	andi	r24, 0x01	; 1
    14d4:	90 70       	andi	r25, 0x00	; 0
    14d6:	88 23       	and	r24, r24
    14d8:	19 f0       	breq	.+6      	; 0x14e0 <GPIO_readPin+0xc2>
				pin_value = LOGIC_HIGH;
    14da:	81 e0       	ldi	r24, 0x01	; 1
    14dc:	89 83       	std	Y+1, r24	; 0x01
    14de:	31 c0       	rjmp	.+98     	; 0x1542 <GPIO_readPin+0x124>
			} else {
				pin_value = LOGIC_LOW;
    14e0:	19 82       	std	Y+1, r1	; 0x01
    14e2:	2f c0       	rjmp	.+94     	; 0x1542 <GPIO_readPin+0x124>
			}
			break;
		case PORTC_ID:
			if (BIT_IS_SET(PINC, pin_num)) {
    14e4:	e3 e3       	ldi	r30, 0x33	; 51
    14e6:	f0 e0       	ldi	r31, 0x00	; 0
    14e8:	80 81       	ld	r24, Z
    14ea:	28 2f       	mov	r18, r24
    14ec:	30 e0       	ldi	r19, 0x00	; 0
    14ee:	8b 81       	ldd	r24, Y+3	; 0x03
    14f0:	88 2f       	mov	r24, r24
    14f2:	90 e0       	ldi	r25, 0x00	; 0
    14f4:	a9 01       	movw	r20, r18
    14f6:	02 c0       	rjmp	.+4      	; 0x14fc <GPIO_readPin+0xde>
    14f8:	55 95       	asr	r21
    14fa:	47 95       	ror	r20
    14fc:	8a 95       	dec	r24
    14fe:	e2 f7       	brpl	.-8      	; 0x14f8 <GPIO_readPin+0xda>
    1500:	ca 01       	movw	r24, r20
    1502:	81 70       	andi	r24, 0x01	; 1
    1504:	90 70       	andi	r25, 0x00	; 0
    1506:	88 23       	and	r24, r24
    1508:	19 f0       	breq	.+6      	; 0x1510 <GPIO_readPin+0xf2>
				pin_value = LOGIC_HIGH;
    150a:	81 e0       	ldi	r24, 0x01	; 1
    150c:	89 83       	std	Y+1, r24	; 0x01
    150e:	19 c0       	rjmp	.+50     	; 0x1542 <GPIO_readPin+0x124>
			} else {
				pin_value = LOGIC_LOW;
    1510:	19 82       	std	Y+1, r1	; 0x01
    1512:	17 c0       	rjmp	.+46     	; 0x1542 <GPIO_readPin+0x124>
			}
			break;
		case PORTD_ID:
			if (BIT_IS_SET(PIND, pin_num)) {
    1514:	e0 e3       	ldi	r30, 0x30	; 48
    1516:	f0 e0       	ldi	r31, 0x00	; 0
    1518:	80 81       	ld	r24, Z
    151a:	28 2f       	mov	r18, r24
    151c:	30 e0       	ldi	r19, 0x00	; 0
    151e:	8b 81       	ldd	r24, Y+3	; 0x03
    1520:	88 2f       	mov	r24, r24
    1522:	90 e0       	ldi	r25, 0x00	; 0
    1524:	a9 01       	movw	r20, r18
    1526:	02 c0       	rjmp	.+4      	; 0x152c <GPIO_readPin+0x10e>
    1528:	55 95       	asr	r21
    152a:	47 95       	ror	r20
    152c:	8a 95       	dec	r24
    152e:	e2 f7       	brpl	.-8      	; 0x1528 <GPIO_readPin+0x10a>
    1530:	ca 01       	movw	r24, r20
    1532:	81 70       	andi	r24, 0x01	; 1
    1534:	90 70       	andi	r25, 0x00	; 0
    1536:	88 23       	and	r24, r24
    1538:	19 f0       	breq	.+6      	; 0x1540 <GPIO_readPin+0x122>
				pin_value = LOGIC_HIGH;
    153a:	81 e0       	ldi	r24, 0x01	; 1
    153c:	89 83       	std	Y+1, r24	; 0x01
    153e:	01 c0       	rjmp	.+2      	; 0x1542 <GPIO_readPin+0x124>
			} else {
				pin_value = LOGIC_LOW;
    1540:	19 82       	std	Y+1, r1	; 0x01
			}
			break;
		}
	}

	return pin_value;
    1542:	89 81       	ldd	r24, Y+1	; 0x01
}
    1544:	0f 90       	pop	r0
    1546:	0f 90       	pop	r0
    1548:	0f 90       	pop	r0
    154a:	0f 90       	pop	r0
    154c:	0f 90       	pop	r0
    154e:	cf 91       	pop	r28
    1550:	df 91       	pop	r29
    1552:	08 95       	ret

00001554 <GPIO_setupPortDirection>:
 * Setup the direction of the required port all pins input/output.
 * If the direction value is PORT_INPUT all pins in this port should be input pins.
 * If the direction value is PORT_OUTPUT all pins in this port should be output pins.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_setupPortDirection(uint8 port_num, GPIO_PortDirectionType direction) {
    1554:	df 93       	push	r29
    1556:	cf 93       	push	r28
    1558:	00 d0       	rcall	.+0      	; 0x155a <GPIO_setupPortDirection+0x6>
    155a:	00 d0       	rcall	.+0      	; 0x155c <GPIO_setupPortDirection+0x8>
    155c:	cd b7       	in	r28, 0x3d	; 61
    155e:	de b7       	in	r29, 0x3e	; 62
    1560:	89 83       	std	Y+1, r24	; 0x01
    1562:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if (port_num >= NUM_OF_PORTS) {
    1564:	89 81       	ldd	r24, Y+1	; 0x01
    1566:	84 30       	cpi	r24, 0x04	; 4
    1568:	90 f5       	brcc	.+100    	; 0x15ce <GPIO_setupPortDirection+0x7a>
		/* Do Nothing */
	} else {
		/* Setup the port direction as required */
		switch (port_num) {
    156a:	89 81       	ldd	r24, Y+1	; 0x01
    156c:	28 2f       	mov	r18, r24
    156e:	30 e0       	ldi	r19, 0x00	; 0
    1570:	3c 83       	std	Y+4, r19	; 0x04
    1572:	2b 83       	std	Y+3, r18	; 0x03
    1574:	8b 81       	ldd	r24, Y+3	; 0x03
    1576:	9c 81       	ldd	r25, Y+4	; 0x04
    1578:	81 30       	cpi	r24, 0x01	; 1
    157a:	91 05       	cpc	r25, r1
    157c:	d1 f0       	breq	.+52     	; 0x15b2 <GPIO_setupPortDirection+0x5e>
    157e:	2b 81       	ldd	r18, Y+3	; 0x03
    1580:	3c 81       	ldd	r19, Y+4	; 0x04
    1582:	22 30       	cpi	r18, 0x02	; 2
    1584:	31 05       	cpc	r19, r1
    1586:	2c f4       	brge	.+10     	; 0x1592 <GPIO_setupPortDirection+0x3e>
    1588:	8b 81       	ldd	r24, Y+3	; 0x03
    158a:	9c 81       	ldd	r25, Y+4	; 0x04
    158c:	00 97       	sbiw	r24, 0x00	; 0
    158e:	61 f0       	breq	.+24     	; 0x15a8 <GPIO_setupPortDirection+0x54>
    1590:	1e c0       	rjmp	.+60     	; 0x15ce <GPIO_setupPortDirection+0x7a>
    1592:	2b 81       	ldd	r18, Y+3	; 0x03
    1594:	3c 81       	ldd	r19, Y+4	; 0x04
    1596:	22 30       	cpi	r18, 0x02	; 2
    1598:	31 05       	cpc	r19, r1
    159a:	81 f0       	breq	.+32     	; 0x15bc <GPIO_setupPortDirection+0x68>
    159c:	8b 81       	ldd	r24, Y+3	; 0x03
    159e:	9c 81       	ldd	r25, Y+4	; 0x04
    15a0:	83 30       	cpi	r24, 0x03	; 3
    15a2:	91 05       	cpc	r25, r1
    15a4:	81 f0       	breq	.+32     	; 0x15c6 <GPIO_setupPortDirection+0x72>
    15a6:	13 c0       	rjmp	.+38     	; 0x15ce <GPIO_setupPortDirection+0x7a>
		case PORTA_ID:
			DDRA = direction;
    15a8:	ea e3       	ldi	r30, 0x3A	; 58
    15aa:	f0 e0       	ldi	r31, 0x00	; 0
    15ac:	8a 81       	ldd	r24, Y+2	; 0x02
    15ae:	80 83       	st	Z, r24
    15b0:	0e c0       	rjmp	.+28     	; 0x15ce <GPIO_setupPortDirection+0x7a>
			break;
		case PORTB_ID:
			DDRB = direction;
    15b2:	e7 e3       	ldi	r30, 0x37	; 55
    15b4:	f0 e0       	ldi	r31, 0x00	; 0
    15b6:	8a 81       	ldd	r24, Y+2	; 0x02
    15b8:	80 83       	st	Z, r24
    15ba:	09 c0       	rjmp	.+18     	; 0x15ce <GPIO_setupPortDirection+0x7a>
			break;
		case PORTC_ID:
			DDRC = direction;
    15bc:	e4 e3       	ldi	r30, 0x34	; 52
    15be:	f0 e0       	ldi	r31, 0x00	; 0
    15c0:	8a 81       	ldd	r24, Y+2	; 0x02
    15c2:	80 83       	st	Z, r24
    15c4:	04 c0       	rjmp	.+8      	; 0x15ce <GPIO_setupPortDirection+0x7a>
			break;
		case PORTD_ID:
			DDRD = direction;
    15c6:	e1 e3       	ldi	r30, 0x31	; 49
    15c8:	f0 e0       	ldi	r31, 0x00	; 0
    15ca:	8a 81       	ldd	r24, Y+2	; 0x02
    15cc:	80 83       	st	Z, r24
			break;
		}
	}
}
    15ce:	0f 90       	pop	r0
    15d0:	0f 90       	pop	r0
    15d2:	0f 90       	pop	r0
    15d4:	0f 90       	pop	r0
    15d6:	cf 91       	pop	r28
    15d8:	df 91       	pop	r29
    15da:	08 95       	ret

000015dc <GPIO_writePort>:
 * Write the value on the required port.
 * If any pin in the port is output pin the value will be written.
 * If any pin in the port is input pin this will activate/deactivate the internal pull-up resistor.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_writePort(uint8 port_num, uint8 value) {
    15dc:	df 93       	push	r29
    15de:	cf 93       	push	r28
    15e0:	00 d0       	rcall	.+0      	; 0x15e2 <GPIO_writePort+0x6>
    15e2:	00 d0       	rcall	.+0      	; 0x15e4 <GPIO_writePort+0x8>
    15e4:	cd b7       	in	r28, 0x3d	; 61
    15e6:	de b7       	in	r29, 0x3e	; 62
    15e8:	89 83       	std	Y+1, r24	; 0x01
    15ea:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if (port_num >= NUM_OF_PORTS) {
    15ec:	89 81       	ldd	r24, Y+1	; 0x01
    15ee:	84 30       	cpi	r24, 0x04	; 4
    15f0:	90 f5       	brcc	.+100    	; 0x1656 <GPIO_writePort+0x7a>
		/* Do Nothing */
	} else {
		/* Write the port value as required */
		switch (port_num) {
    15f2:	89 81       	ldd	r24, Y+1	; 0x01
    15f4:	28 2f       	mov	r18, r24
    15f6:	30 e0       	ldi	r19, 0x00	; 0
    15f8:	3c 83       	std	Y+4, r19	; 0x04
    15fa:	2b 83       	std	Y+3, r18	; 0x03
    15fc:	8b 81       	ldd	r24, Y+3	; 0x03
    15fe:	9c 81       	ldd	r25, Y+4	; 0x04
    1600:	81 30       	cpi	r24, 0x01	; 1
    1602:	91 05       	cpc	r25, r1
    1604:	d1 f0       	breq	.+52     	; 0x163a <GPIO_writePort+0x5e>
    1606:	2b 81       	ldd	r18, Y+3	; 0x03
    1608:	3c 81       	ldd	r19, Y+4	; 0x04
    160a:	22 30       	cpi	r18, 0x02	; 2
    160c:	31 05       	cpc	r19, r1
    160e:	2c f4       	brge	.+10     	; 0x161a <GPIO_writePort+0x3e>
    1610:	8b 81       	ldd	r24, Y+3	; 0x03
    1612:	9c 81       	ldd	r25, Y+4	; 0x04
    1614:	00 97       	sbiw	r24, 0x00	; 0
    1616:	61 f0       	breq	.+24     	; 0x1630 <GPIO_writePort+0x54>
    1618:	1e c0       	rjmp	.+60     	; 0x1656 <GPIO_writePort+0x7a>
    161a:	2b 81       	ldd	r18, Y+3	; 0x03
    161c:	3c 81       	ldd	r19, Y+4	; 0x04
    161e:	22 30       	cpi	r18, 0x02	; 2
    1620:	31 05       	cpc	r19, r1
    1622:	81 f0       	breq	.+32     	; 0x1644 <GPIO_writePort+0x68>
    1624:	8b 81       	ldd	r24, Y+3	; 0x03
    1626:	9c 81       	ldd	r25, Y+4	; 0x04
    1628:	83 30       	cpi	r24, 0x03	; 3
    162a:	91 05       	cpc	r25, r1
    162c:	81 f0       	breq	.+32     	; 0x164e <GPIO_writePort+0x72>
    162e:	13 c0       	rjmp	.+38     	; 0x1656 <GPIO_writePort+0x7a>
		case PORTA_ID:
			PORTA = value;
    1630:	eb e3       	ldi	r30, 0x3B	; 59
    1632:	f0 e0       	ldi	r31, 0x00	; 0
    1634:	8a 81       	ldd	r24, Y+2	; 0x02
    1636:	80 83       	st	Z, r24
    1638:	0e c0       	rjmp	.+28     	; 0x1656 <GPIO_writePort+0x7a>
			break;
		case PORTB_ID:
			PORTB = value;
    163a:	e8 e3       	ldi	r30, 0x38	; 56
    163c:	f0 e0       	ldi	r31, 0x00	; 0
    163e:	8a 81       	ldd	r24, Y+2	; 0x02
    1640:	80 83       	st	Z, r24
    1642:	09 c0       	rjmp	.+18     	; 0x1656 <GPIO_writePort+0x7a>
			break;
		case PORTC_ID:
			PORTC = value;
    1644:	e5 e3       	ldi	r30, 0x35	; 53
    1646:	f0 e0       	ldi	r31, 0x00	; 0
    1648:	8a 81       	ldd	r24, Y+2	; 0x02
    164a:	80 83       	st	Z, r24
    164c:	04 c0       	rjmp	.+8      	; 0x1656 <GPIO_writePort+0x7a>
			break;
		case PORTD_ID:
			PORTD = value;
    164e:	e2 e3       	ldi	r30, 0x32	; 50
    1650:	f0 e0       	ldi	r31, 0x00	; 0
    1652:	8a 81       	ldd	r24, Y+2	; 0x02
    1654:	80 83       	st	Z, r24
			break;
		}
	}
}
    1656:	0f 90       	pop	r0
    1658:	0f 90       	pop	r0
    165a:	0f 90       	pop	r0
    165c:	0f 90       	pop	r0
    165e:	cf 91       	pop	r28
    1660:	df 91       	pop	r29
    1662:	08 95       	ret

00001664 <GPIO_readPort>:
/*
 * Description :
 * Read and return the value of the required port.
 * If the input port number is not correct, The function will return ZERO value.
 */
uint8 GPIO_readPort(uint8 port_num) {
    1664:	df 93       	push	r29
    1666:	cf 93       	push	r28
    1668:	00 d0       	rcall	.+0      	; 0x166a <GPIO_readPort+0x6>
    166a:	00 d0       	rcall	.+0      	; 0x166c <GPIO_readPort+0x8>
    166c:	cd b7       	in	r28, 0x3d	; 61
    166e:	de b7       	in	r29, 0x3e	; 62
    1670:	8a 83       	std	Y+2, r24	; 0x02
	uint8 value = LOGIC_LOW;
    1672:	19 82       	std	Y+1, r1	; 0x01

	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if (port_num >= NUM_OF_PORTS) {
    1674:	8a 81       	ldd	r24, Y+2	; 0x02
    1676:	84 30       	cpi	r24, 0x04	; 4
    1678:	90 f5       	brcc	.+100    	; 0x16de <GPIO_readPort+0x7a>
		/* Do Nothing */
	} else {
		/* Read the port value as required */
		switch (port_num) {
    167a:	8a 81       	ldd	r24, Y+2	; 0x02
    167c:	28 2f       	mov	r18, r24
    167e:	30 e0       	ldi	r19, 0x00	; 0
    1680:	3c 83       	std	Y+4, r19	; 0x04
    1682:	2b 83       	std	Y+3, r18	; 0x03
    1684:	8b 81       	ldd	r24, Y+3	; 0x03
    1686:	9c 81       	ldd	r25, Y+4	; 0x04
    1688:	81 30       	cpi	r24, 0x01	; 1
    168a:	91 05       	cpc	r25, r1
    168c:	d1 f0       	breq	.+52     	; 0x16c2 <GPIO_readPort+0x5e>
    168e:	2b 81       	ldd	r18, Y+3	; 0x03
    1690:	3c 81       	ldd	r19, Y+4	; 0x04
    1692:	22 30       	cpi	r18, 0x02	; 2
    1694:	31 05       	cpc	r19, r1
    1696:	2c f4       	brge	.+10     	; 0x16a2 <GPIO_readPort+0x3e>
    1698:	8b 81       	ldd	r24, Y+3	; 0x03
    169a:	9c 81       	ldd	r25, Y+4	; 0x04
    169c:	00 97       	sbiw	r24, 0x00	; 0
    169e:	61 f0       	breq	.+24     	; 0x16b8 <GPIO_readPort+0x54>
    16a0:	1e c0       	rjmp	.+60     	; 0x16de <GPIO_readPort+0x7a>
    16a2:	2b 81       	ldd	r18, Y+3	; 0x03
    16a4:	3c 81       	ldd	r19, Y+4	; 0x04
    16a6:	22 30       	cpi	r18, 0x02	; 2
    16a8:	31 05       	cpc	r19, r1
    16aa:	81 f0       	breq	.+32     	; 0x16cc <GPIO_readPort+0x68>
    16ac:	8b 81       	ldd	r24, Y+3	; 0x03
    16ae:	9c 81       	ldd	r25, Y+4	; 0x04
    16b0:	83 30       	cpi	r24, 0x03	; 3
    16b2:	91 05       	cpc	r25, r1
    16b4:	81 f0       	breq	.+32     	; 0x16d6 <GPIO_readPort+0x72>
    16b6:	13 c0       	rjmp	.+38     	; 0x16de <GPIO_readPort+0x7a>
		case PORTA_ID:
			value = PINA;
    16b8:	e9 e3       	ldi	r30, 0x39	; 57
    16ba:	f0 e0       	ldi	r31, 0x00	; 0
    16bc:	80 81       	ld	r24, Z
    16be:	89 83       	std	Y+1, r24	; 0x01
    16c0:	0e c0       	rjmp	.+28     	; 0x16de <GPIO_readPort+0x7a>
			break;
		case PORTB_ID:
			value = PINB;
    16c2:	e6 e3       	ldi	r30, 0x36	; 54
    16c4:	f0 e0       	ldi	r31, 0x00	; 0
    16c6:	80 81       	ld	r24, Z
    16c8:	89 83       	std	Y+1, r24	; 0x01
    16ca:	09 c0       	rjmp	.+18     	; 0x16de <GPIO_readPort+0x7a>
			break;
		case PORTC_ID:
			value = PINC;
    16cc:	e3 e3       	ldi	r30, 0x33	; 51
    16ce:	f0 e0       	ldi	r31, 0x00	; 0
    16d0:	80 81       	ld	r24, Z
    16d2:	89 83       	std	Y+1, r24	; 0x01
    16d4:	04 c0       	rjmp	.+8      	; 0x16de <GPIO_readPort+0x7a>
			break;
		case PORTD_ID:
			value = PIND;
    16d6:	e0 e3       	ldi	r30, 0x30	; 48
    16d8:	f0 e0       	ldi	r31, 0x00	; 0
    16da:	80 81       	ld	r24, Z
    16dc:	89 83       	std	Y+1, r24	; 0x01
			break;
		}
	}

	return value;
    16de:	89 81       	ldd	r24, Y+1	; 0x01
}
    16e0:	0f 90       	pop	r0
    16e2:	0f 90       	pop	r0
    16e4:	0f 90       	pop	r0
    16e6:	0f 90       	pop	r0
    16e8:	cf 91       	pop	r28
    16ea:	df 91       	pop	r29
    16ec:	08 95       	ret

000016ee <EEPROM_writeByte>:
 */
#include "external_eeprom.h"
#include "../../MCAL/I2C/twi.h"

uint8 EEPROM_writeByte(uint16 u16addr, uint8 u8data)
{
    16ee:	df 93       	push	r29
    16f0:	cf 93       	push	r28
    16f2:	00 d0       	rcall	.+0      	; 0x16f4 <EEPROM_writeByte+0x6>
    16f4:	00 d0       	rcall	.+0      	; 0x16f6 <EEPROM_writeByte+0x8>
    16f6:	cd b7       	in	r28, 0x3d	; 61
    16f8:	de b7       	in	r29, 0x3e	; 62
    16fa:	9a 83       	std	Y+2, r25	; 0x02
    16fc:	89 83       	std	Y+1, r24	; 0x01
    16fe:	6b 83       	std	Y+3, r22	; 0x03
	/* Send the Start Bit */
    TWI_start();
    1700:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <TWI_start>
    if (TWI_getStatus() != TWI_START)
    1704:	0e 94 2a 08 	call	0x1054	; 0x1054 <TWI_getStatus>
    1708:	88 30       	cpi	r24, 0x08	; 8
    170a:	11 f0       	breq	.+4      	; 0x1710 <EEPROM_writeByte+0x22>
        return ERROR;
    170c:	1c 82       	std	Y+4, r1	; 0x04
    170e:	28 c0       	rjmp	.+80     	; 0x1760 <EEPROM_writeByte+0x72>

    /* Send the device address, we need to get A8 A9 A10 address bits from the
     * memory location address and R/W=0 (write) */
    TWI_writeByte((uint8)(0xA0 | ((u16addr & 0x0700)>>7)));
    1710:	89 81       	ldd	r24, Y+1	; 0x01
    1712:	9a 81       	ldd	r25, Y+2	; 0x02
    1714:	80 70       	andi	r24, 0x00	; 0
    1716:	97 70       	andi	r25, 0x07	; 7
    1718:	88 0f       	add	r24, r24
    171a:	89 2f       	mov	r24, r25
    171c:	88 1f       	adc	r24, r24
    171e:	99 0b       	sbc	r25, r25
    1720:	91 95       	neg	r25
    1722:	80 6a       	ori	r24, 0xA0	; 160
    1724:	0e 94 ed 07 	call	0xfda	; 0xfda <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_SLA_W_ACK)
    1728:	0e 94 2a 08 	call	0x1054	; 0x1054 <TWI_getStatus>
    172c:	88 31       	cpi	r24, 0x18	; 24
    172e:	11 f0       	breq	.+4      	; 0x1734 <EEPROM_writeByte+0x46>
        return ERROR;
    1730:	1c 82       	std	Y+4, r1	; 0x04
    1732:	16 c0       	rjmp	.+44     	; 0x1760 <EEPROM_writeByte+0x72>

    /* Send the required memory location address */
    TWI_writeByte((uint8)(u16addr));
    1734:	89 81       	ldd	r24, Y+1	; 0x01
    1736:	0e 94 ed 07 	call	0xfda	; 0xfda <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_DATA_ACK)
    173a:	0e 94 2a 08 	call	0x1054	; 0x1054 <TWI_getStatus>
    173e:	88 32       	cpi	r24, 0x28	; 40
    1740:	11 f0       	breq	.+4      	; 0x1746 <EEPROM_writeByte+0x58>
        return ERROR;
    1742:	1c 82       	std	Y+4, r1	; 0x04
    1744:	0d c0       	rjmp	.+26     	; 0x1760 <EEPROM_writeByte+0x72>

    /* write byte to eeprom */
    TWI_writeByte(u8data);
    1746:	8b 81       	ldd	r24, Y+3	; 0x03
    1748:	0e 94 ed 07 	call	0xfda	; 0xfda <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_DATA_ACK)
    174c:	0e 94 2a 08 	call	0x1054	; 0x1054 <TWI_getStatus>
    1750:	88 32       	cpi	r24, 0x28	; 40
    1752:	11 f0       	breq	.+4      	; 0x1758 <EEPROM_writeByte+0x6a>
        return ERROR;
    1754:	1c 82       	std	Y+4, r1	; 0x04
    1756:	04 c0       	rjmp	.+8      	; 0x1760 <EEPROM_writeByte+0x72>

    /* Send the Stop Bit */
    TWI_stop();
    1758:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <TWI_stop>

    return SUCCESS;
    175c:	81 e0       	ldi	r24, 0x01	; 1
    175e:	8c 83       	std	Y+4, r24	; 0x04
    1760:	8c 81       	ldd	r24, Y+4	; 0x04
}
    1762:	0f 90       	pop	r0
    1764:	0f 90       	pop	r0
    1766:	0f 90       	pop	r0
    1768:	0f 90       	pop	r0
    176a:	cf 91       	pop	r28
    176c:	df 91       	pop	r29
    176e:	08 95       	ret

00001770 <EEPROM_readByte>:

uint8 EEPROM_readByte(uint16 u16addr, uint8 *u8data)
{
    1770:	df 93       	push	r29
    1772:	cf 93       	push	r28
    1774:	00 d0       	rcall	.+0      	; 0x1776 <EEPROM_readByte+0x6>
    1776:	00 d0       	rcall	.+0      	; 0x1778 <EEPROM_readByte+0x8>
    1778:	0f 92       	push	r0
    177a:	cd b7       	in	r28, 0x3d	; 61
    177c:	de b7       	in	r29, 0x3e	; 62
    177e:	9a 83       	std	Y+2, r25	; 0x02
    1780:	89 83       	std	Y+1, r24	; 0x01
    1782:	7c 83       	std	Y+4, r23	; 0x04
    1784:	6b 83       	std	Y+3, r22	; 0x03
	/* Send the Start Bit */
    TWI_start();
    1786:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <TWI_start>
    if (TWI_getStatus() != TWI_START)
    178a:	0e 94 2a 08 	call	0x1054	; 0x1054 <TWI_getStatus>
    178e:	88 30       	cpi	r24, 0x08	; 8
    1790:	11 f0       	breq	.+4      	; 0x1796 <EEPROM_readByte+0x26>
        return ERROR;
    1792:	1d 82       	std	Y+5, r1	; 0x05
    1794:	44 c0       	rjmp	.+136    	; 0x181e <EEPROM_readByte+0xae>

    /* Send the device address, we need to get A8 A9 A10 address bits from the
     * memory location address and R/W=0 (write) */
    TWI_writeByte((uint8)((0xA0) | ((u16addr & 0x0700)>>7)));
    1796:	89 81       	ldd	r24, Y+1	; 0x01
    1798:	9a 81       	ldd	r25, Y+2	; 0x02
    179a:	80 70       	andi	r24, 0x00	; 0
    179c:	97 70       	andi	r25, 0x07	; 7
    179e:	88 0f       	add	r24, r24
    17a0:	89 2f       	mov	r24, r25
    17a2:	88 1f       	adc	r24, r24
    17a4:	99 0b       	sbc	r25, r25
    17a6:	91 95       	neg	r25
    17a8:	80 6a       	ori	r24, 0xA0	; 160
    17aa:	0e 94 ed 07 	call	0xfda	; 0xfda <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_SLA_W_ACK)
    17ae:	0e 94 2a 08 	call	0x1054	; 0x1054 <TWI_getStatus>
    17b2:	88 31       	cpi	r24, 0x18	; 24
    17b4:	11 f0       	breq	.+4      	; 0x17ba <EEPROM_readByte+0x4a>
        return ERROR;
    17b6:	1d 82       	std	Y+5, r1	; 0x05
    17b8:	32 c0       	rjmp	.+100    	; 0x181e <EEPROM_readByte+0xae>

    /* Send the required memory location address */
    TWI_writeByte((uint8)(u16addr));
    17ba:	89 81       	ldd	r24, Y+1	; 0x01
    17bc:	0e 94 ed 07 	call	0xfda	; 0xfda <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_DATA_ACK)
    17c0:	0e 94 2a 08 	call	0x1054	; 0x1054 <TWI_getStatus>
    17c4:	88 32       	cpi	r24, 0x28	; 40
    17c6:	11 f0       	breq	.+4      	; 0x17cc <EEPROM_readByte+0x5c>
        return ERROR;
    17c8:	1d 82       	std	Y+5, r1	; 0x05
    17ca:	29 c0       	rjmp	.+82     	; 0x181e <EEPROM_readByte+0xae>

    /* Send the Repeated Start Bit */
    TWI_start();
    17cc:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <TWI_start>
    if (TWI_getStatus() != TWI_REP_START)
    17d0:	0e 94 2a 08 	call	0x1054	; 0x1054 <TWI_getStatus>
    17d4:	80 31       	cpi	r24, 0x10	; 16
    17d6:	11 f0       	breq	.+4      	; 0x17dc <EEPROM_readByte+0x6c>
        return ERROR;
    17d8:	1d 82       	std	Y+5, r1	; 0x05
    17da:	21 c0       	rjmp	.+66     	; 0x181e <EEPROM_readByte+0xae>

    /* Send the device address, we need to get A8 A9 A10 address bits from the
     * memory location address and R/W=1 (Read) */
    TWI_writeByte((uint8)((0xA0) | ((u16addr & 0x0700)>>7) | 1));
    17dc:	89 81       	ldd	r24, Y+1	; 0x01
    17de:	9a 81       	ldd	r25, Y+2	; 0x02
    17e0:	80 70       	andi	r24, 0x00	; 0
    17e2:	97 70       	andi	r25, 0x07	; 7
    17e4:	88 0f       	add	r24, r24
    17e6:	89 2f       	mov	r24, r25
    17e8:	88 1f       	adc	r24, r24
    17ea:	99 0b       	sbc	r25, r25
    17ec:	91 95       	neg	r25
    17ee:	81 6a       	ori	r24, 0xA1	; 161
    17f0:	0e 94 ed 07 	call	0xfda	; 0xfda <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_SLA_R_ACK)
    17f4:	0e 94 2a 08 	call	0x1054	; 0x1054 <TWI_getStatus>
    17f8:	80 34       	cpi	r24, 0x40	; 64
    17fa:	11 f0       	breq	.+4      	; 0x1800 <EEPROM_readByte+0x90>
        return ERROR;
    17fc:	1d 82       	std	Y+5, r1	; 0x05
    17fe:	0f c0       	rjmp	.+30     	; 0x181e <EEPROM_readByte+0xae>

    /* Read Byte from Memory without send ACK */
    *u8data = TWI_readByteWithNACK();
    1800:	0e 94 17 08 	call	0x102e	; 0x102e <TWI_readByteWithNACK>
    1804:	eb 81       	ldd	r30, Y+3	; 0x03
    1806:	fc 81       	ldd	r31, Y+4	; 0x04
    1808:	80 83       	st	Z, r24
    if (TWI_getStatus() != TWI_MR_DATA_NACK)
    180a:	0e 94 2a 08 	call	0x1054	; 0x1054 <TWI_getStatus>
    180e:	88 35       	cpi	r24, 0x58	; 88
    1810:	11 f0       	breq	.+4      	; 0x1816 <EEPROM_readByte+0xa6>
        return ERROR;
    1812:	1d 82       	std	Y+5, r1	; 0x05
    1814:	04 c0       	rjmp	.+8      	; 0x181e <EEPROM_readByte+0xae>

    /* Send the Stop Bit */
    TWI_stop();
    1816:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <TWI_stop>

    return SUCCESS;
    181a:	81 e0       	ldi	r24, 0x01	; 1
    181c:	8d 83       	std	Y+5, r24	; 0x05
    181e:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1820:	0f 90       	pop	r0
    1822:	0f 90       	pop	r0
    1824:	0f 90       	pop	r0
    1826:	0f 90       	pop	r0
    1828:	0f 90       	pop	r0
    182a:	cf 91       	pop	r28
    182c:	df 91       	pop	r29
    182e:	08 95       	ret

00001830 <DcMotor_Init>:

/*
 * Description :
 * Function responsible for initialize the DC_Motor driver.
 */
void DcMotor_Init(void) {
    1830:	df 93       	push	r29
    1832:	cf 93       	push	r28
    1834:	cd b7       	in	r28, 0x3d	; 61
    1836:	de b7       	in	r29, 0x3e	; 62
	GPIO_setupPinDirection(DC_MOTOR_FIRST_PORT_ID , DC_MOTOR_FIRST_PIN_ID, PIN_OUTPUT);
    1838:	81 e0       	ldi	r24, 0x01	; 1
    183a:	60 e0       	ldi	r22, 0x00	; 0
    183c:	41 e0       	ldi	r20, 0x01	; 1
    183e:	0e 94 39 08 	call	0x1072	; 0x1072 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(DC_MOTOR_SECOND_PORT_ID, DC_MOTOR_SECOND_PIN_ID, PIN_OUTPUT);
    1842:	81 e0       	ldi	r24, 0x01	; 1
    1844:	61 e0       	ldi	r22, 0x01	; 1
    1846:	41 e0       	ldi	r20, 0x01	; 1
    1848:	0e 94 39 08 	call	0x1072	; 0x1072 <GPIO_setupPinDirection>
	GPIO_writePin(DC_MOTOR_FIRST_PORT_ID , DC_MOTOR_FIRST_PIN_ID, LOGIC_LOW);
    184c:	81 e0       	ldi	r24, 0x01	; 1
    184e:	60 e0       	ldi	r22, 0x00	; 0
    1850:	40 e0       	ldi	r20, 0x00	; 0
    1852:	0e 94 24 09 	call	0x1248	; 0x1248 <GPIO_writePin>
	GPIO_writePin(DC_MOTOR_SECOND_PORT_ID, DC_MOTOR_SECOND_PIN_ID, LOGIC_LOW);
    1856:	81 e0       	ldi	r24, 0x01	; 1
    1858:	61 e0       	ldi	r22, 0x01	; 1
    185a:	40 e0       	ldi	r20, 0x00	; 0
    185c:	0e 94 24 09 	call	0x1248	; 0x1248 <GPIO_writePin>
}
    1860:	cf 91       	pop	r28
    1862:	df 91       	pop	r29
    1864:	08 95       	ret

00001866 <DcMotor_Rotate>:

/*
 * Description :
 * Function responsible for initialize the DC_Motor_Rotate driver.
 */
void DcMotor_Rotate(DcMotor_State state, uint8 speed){
    1866:	df 93       	push	r29
    1868:	cf 93       	push	r28
    186a:	00 d0       	rcall	.+0      	; 0x186c <DcMotor_Rotate+0x6>
    186c:	00 d0       	rcall	.+0      	; 0x186e <DcMotor_Rotate+0x8>
    186e:	cd b7       	in	r28, 0x3d	; 61
    1870:	de b7       	in	r29, 0x3e	; 62
    1872:	89 83       	std	Y+1, r24	; 0x01
    1874:	6a 83       	std	Y+2, r22	; 0x02
	switch(state){
    1876:	89 81       	ldd	r24, Y+1	; 0x01
    1878:	28 2f       	mov	r18, r24
    187a:	30 e0       	ldi	r19, 0x00	; 0
    187c:	3c 83       	std	Y+4, r19	; 0x04
    187e:	2b 83       	std	Y+3, r18	; 0x03
    1880:	8b 81       	ldd	r24, Y+3	; 0x03
    1882:	9c 81       	ldd	r25, Y+4	; 0x04
    1884:	81 30       	cpi	r24, 0x01	; 1
    1886:	91 05       	cpc	r25, r1
    1888:	a1 f0       	breq	.+40     	; 0x18b2 <DcMotor_Rotate+0x4c>
    188a:	2b 81       	ldd	r18, Y+3	; 0x03
    188c:	3c 81       	ldd	r19, Y+4	; 0x04
    188e:	22 30       	cpi	r18, 0x02	; 2
    1890:	31 05       	cpc	r19, r1
    1892:	d1 f0       	breq	.+52     	; 0x18c8 <DcMotor_Rotate+0x62>
    1894:	8b 81       	ldd	r24, Y+3	; 0x03
    1896:	9c 81       	ldd	r25, Y+4	; 0x04
    1898:	00 97       	sbiw	r24, 0x00	; 0
    189a:	01 f5       	brne	.+64     	; 0x18dc <DcMotor_Rotate+0x76>
	case STOP:
		GPIO_writePin(DC_MOTOR_FIRST_PORT_ID, DC_MOTOR_FIRST_PIN_ID, LOGIC_LOW);
    189c:	81 e0       	ldi	r24, 0x01	; 1
    189e:	60 e0       	ldi	r22, 0x00	; 0
    18a0:	40 e0       	ldi	r20, 0x00	; 0
    18a2:	0e 94 24 09 	call	0x1248	; 0x1248 <GPIO_writePin>
		GPIO_writePin(DC_MOTOR_SECOND_PORT_ID, DC_MOTOR_SECOND_PIN_ID, LOGIC_LOW);
    18a6:	81 e0       	ldi	r24, 0x01	; 1
    18a8:	61 e0       	ldi	r22, 0x01	; 1
    18aa:	40 e0       	ldi	r20, 0x00	; 0
    18ac:	0e 94 24 09 	call	0x1248	; 0x1248 <GPIO_writePin>
    18b0:	15 c0       	rjmp	.+42     	; 0x18dc <DcMotor_Rotate+0x76>
		break;
	case CW:
		GPIO_writePin(DC_MOTOR_FIRST_PORT_ID , DC_MOTOR_FIRST_PIN_ID, LOGIC_HIGH);
    18b2:	81 e0       	ldi	r24, 0x01	; 1
    18b4:	60 e0       	ldi	r22, 0x00	; 0
    18b6:	41 e0       	ldi	r20, 0x01	; 1
    18b8:	0e 94 24 09 	call	0x1248	; 0x1248 <GPIO_writePin>
		GPIO_writePin(DC_MOTOR_SECOND_PORT_ID, DC_MOTOR_SECOND_PIN_ID, LOGIC_LOW);
    18bc:	81 e0       	ldi	r24, 0x01	; 1
    18be:	61 e0       	ldi	r22, 0x01	; 1
    18c0:	40 e0       	ldi	r20, 0x00	; 0
    18c2:	0e 94 24 09 	call	0x1248	; 0x1248 <GPIO_writePin>
    18c6:	0a c0       	rjmp	.+20     	; 0x18dc <DcMotor_Rotate+0x76>
		break;
	case A_CW:
		GPIO_writePin(DC_MOTOR_FIRST_PORT_ID , DC_MOTOR_FIRST_PIN_ID, LOGIC_LOW);
    18c8:	81 e0       	ldi	r24, 0x01	; 1
    18ca:	60 e0       	ldi	r22, 0x00	; 0
    18cc:	40 e0       	ldi	r20, 0x00	; 0
    18ce:	0e 94 24 09 	call	0x1248	; 0x1248 <GPIO_writePin>
		GPIO_writePin(DC_MOTOR_SECOND_PORT_ID, DC_MOTOR_SECOND_PIN_ID, LOGIC_HIGH);
    18d2:	81 e0       	ldi	r24, 0x01	; 1
    18d4:	61 e0       	ldi	r22, 0x01	; 1
    18d6:	41 e0       	ldi	r20, 0x01	; 1
    18d8:	0e 94 24 09 	call	0x1248	; 0x1248 <GPIO_writePin>
		break;
	}

	PWM_Timer0_Start(speed);
    18dc:	8a 81       	ldd	r24, Y+2	; 0x02
    18de:	0e 94 83 07 	call	0xf06	; 0xf06 <PWM_Timer0_Start>

}
    18e2:	0f 90       	pop	r0
    18e4:	0f 90       	pop	r0
    18e6:	0f 90       	pop	r0
    18e8:	0f 90       	pop	r0
    18ea:	cf 91       	pop	r28
    18ec:	df 91       	pop	r29
    18ee:	08 95       	ret

000018f0 <Buzzer_init>:
#include "../../inc/common_macros.h"
#include "../../MCAL/GPIO/gpio.h"


void Buzzer_init()
{
    18f0:	df 93       	push	r29
    18f2:	cf 93       	push	r28
    18f4:	cd b7       	in	r28, 0x3d	; 61
    18f6:	de b7       	in	r29, 0x3e	; 62
	GPIO_setupPinDirection(BUZZER_PORT_ID,BUZZER_PIN_ID,PIN_OUTPUT);
    18f8:	81 e0       	ldi	r24, 0x01	; 1
    18fa:	65 e0       	ldi	r22, 0x05	; 5
    18fc:	41 e0       	ldi	r20, 0x01	; 1
    18fe:	0e 94 39 08 	call	0x1072	; 0x1072 <GPIO_setupPinDirection>
	GPIO_writePin(BUZZER_PORT_ID,BUZZER_PIN_ID,LOGIC_LOW);
    1902:	81 e0       	ldi	r24, 0x01	; 1
    1904:	65 e0       	ldi	r22, 0x05	; 5
    1906:	40 e0       	ldi	r20, 0x00	; 0
    1908:	0e 94 24 09 	call	0x1248	; 0x1248 <GPIO_writePin>
}
    190c:	cf 91       	pop	r28
    190e:	df 91       	pop	r29
    1910:	08 95       	ret

00001912 <Buzzer_on>:

void Buzzer_on(void)
{
    1912:	df 93       	push	r29
    1914:	cf 93       	push	r28
    1916:	cd b7       	in	r28, 0x3d	; 61
    1918:	de b7       	in	r29, 0x3e	; 62
	GPIO_writePin(BUZZER_PORT_ID,BUZZER_PIN_ID,LOGIC_HIGH);
    191a:	81 e0       	ldi	r24, 0x01	; 1
    191c:	65 e0       	ldi	r22, 0x05	; 5
    191e:	41 e0       	ldi	r20, 0x01	; 1
    1920:	0e 94 24 09 	call	0x1248	; 0x1248 <GPIO_writePin>
}
    1924:	cf 91       	pop	r28
    1926:	df 91       	pop	r29
    1928:	08 95       	ret

0000192a <Buzzer_off>:

void Buzzer_off(void)
{
    192a:	df 93       	push	r29
    192c:	cf 93       	push	r28
    192e:	cd b7       	in	r28, 0x3d	; 61
    1930:	de b7       	in	r29, 0x3e	; 62
	GPIO_writePin(BUZZER_PORT_ID,BUZZER_PIN_ID,LOGIC_LOW);
    1932:	81 e0       	ldi	r24, 0x01	; 1
    1934:	65 e0       	ldi	r22, 0x05	; 5
    1936:	40 e0       	ldi	r20, 0x00	; 0
    1938:	0e 94 24 09 	call	0x1248	; 0x1248 <GPIO_writePin>
}
    193c:	cf 91       	pop	r28
    193e:	df 91       	pop	r29
    1940:	08 95       	ret

00001942 <main>:
#include<avr/io.h>
#include<avr/interrupt.h>
#include <util/delay.h>

int main(void)
{
    1942:	df 93       	push	r29
    1944:	cf 93       	push	r28
    1946:	cd b7       	in	r28, 0x3d	; 61
    1948:	de b7       	in	r29, 0x3e	; 62
    194a:	c8 55       	subi	r28, 0x58	; 88
    194c:	d0 40       	sbci	r29, 0x00	; 0
    194e:	0f b6       	in	r0, 0x3f	; 63
    1950:	f8 94       	cli
    1952:	de bf       	out	0x3e, r29	; 62
    1954:	0f be       	out	0x3f, r0	; 63
    1956:	cd bf       	out	0x3d, r28	; 61
	/*
	 * Enable global interrupts
	 * */
	sei();
    1958:	78 94       	sei
		* Date Length: 8-Bits Data
		* Parity Type: Even Parity
		* Stop Bits: 1-Stop Bit
	  	* baud rate is 9600
	 */
	UART_ConfigType UART_config = { _8BIT, EVEN, ONE, 9600};
    195a:	ce 01       	movw	r24, r28
    195c:	85 5b       	subi	r24, 0xB5	; 181
    195e:	9f 4f       	sbci	r25, 0xFF	; 255
    1960:	66 96       	adiw	r28, 0x16	; 22
    1962:	9f af       	std	Y+63, r25	; 0x3f
    1964:	8e af       	std	Y+62, r24	; 0x3e
    1966:	66 97       	sbiw	r28, 0x16	; 22
    1968:	2a e6       	ldi	r18, 0x6A	; 106
    196a:	30 e0       	ldi	r19, 0x00	; 0
    196c:	68 96       	adiw	r28, 0x18	; 24
    196e:	3f af       	std	Y+63, r19	; 0x3f
    1970:	2e af       	std	Y+62, r18	; 0x3e
    1972:	68 97       	sbiw	r28, 0x18	; 24
    1974:	35 e0       	ldi	r19, 0x05	; 5
    1976:	69 96       	adiw	r28, 0x19	; 25
    1978:	3f af       	std	Y+63, r19	; 0x3f
    197a:	69 97       	sbiw	r28, 0x19	; 25
    197c:	68 96       	adiw	r28, 0x18	; 24
    197e:	ee ad       	ldd	r30, Y+62	; 0x3e
    1980:	ff ad       	ldd	r31, Y+63	; 0x3f
    1982:	68 97       	sbiw	r28, 0x18	; 24
    1984:	00 80       	ld	r0, Z
    1986:	68 96       	adiw	r28, 0x18	; 24
    1988:	2e ad       	ldd	r18, Y+62	; 0x3e
    198a:	3f ad       	ldd	r19, Y+63	; 0x3f
    198c:	68 97       	sbiw	r28, 0x18	; 24
    198e:	2f 5f       	subi	r18, 0xFF	; 255
    1990:	3f 4f       	sbci	r19, 0xFF	; 255
    1992:	68 96       	adiw	r28, 0x18	; 24
    1994:	3f af       	std	Y+63, r19	; 0x3f
    1996:	2e af       	std	Y+62, r18	; 0x3e
    1998:	68 97       	sbiw	r28, 0x18	; 24
    199a:	66 96       	adiw	r28, 0x16	; 22
    199c:	ee ad       	ldd	r30, Y+62	; 0x3e
    199e:	ff ad       	ldd	r31, Y+63	; 0x3f
    19a0:	66 97       	sbiw	r28, 0x16	; 22
    19a2:	00 82       	st	Z, r0
    19a4:	66 96       	adiw	r28, 0x16	; 22
    19a6:	2e ad       	ldd	r18, Y+62	; 0x3e
    19a8:	3f ad       	ldd	r19, Y+63	; 0x3f
    19aa:	66 97       	sbiw	r28, 0x16	; 22
    19ac:	2f 5f       	subi	r18, 0xFF	; 255
    19ae:	3f 4f       	sbci	r19, 0xFF	; 255
    19b0:	66 96       	adiw	r28, 0x16	; 22
    19b2:	3f af       	std	Y+63, r19	; 0x3f
    19b4:	2e af       	std	Y+62, r18	; 0x3e
    19b6:	66 97       	sbiw	r28, 0x16	; 22
    19b8:	69 96       	adiw	r28, 0x19	; 25
    19ba:	3f ad       	ldd	r19, Y+63	; 0x3f
    19bc:	69 97       	sbiw	r28, 0x19	; 25
    19be:	31 50       	subi	r19, 0x01	; 1
    19c0:	69 96       	adiw	r28, 0x19	; 25
    19c2:	3f af       	std	Y+63, r19	; 0x3f
    19c4:	69 97       	sbiw	r28, 0x19	; 25
    19c6:	69 96       	adiw	r28, 0x19	; 25
    19c8:	8f ad       	ldd	r24, Y+63	; 0x3f
    19ca:	69 97       	sbiw	r28, 0x19	; 25
    19cc:	88 23       	and	r24, r24
    19ce:	b1 f6       	brne	.-84     	; 0x197c <main+0x3a>
	UART_init(&UART_config);
    19d0:	ce 01       	movw	r24, r28
    19d2:	85 5b       	subi	r24, 0xB5	; 181
    19d4:	9f 4f       	sbci	r25, 0xFF	; 255
    19d6:	0e 94 87 06 	call	0xd0e	; 0xd0e <UART_init>
	 * Bit rate 400kb/s
	 * F_CPU = 8MHz
	 * Interrupt OFF
	 * Acknowledge OFF
	 */
	TWI_ConfigType TWI_Config = {slave1_addr, FAST_400KB};
    19da:	fe 01       	movw	r30, r28
    19dc:	e0 5b       	subi	r30, 0xB0	; 176
    19de:	ff 4f       	sbci	r31, 0xFF	; 255
    19e0:	82 e0       	ldi	r24, 0x02	; 2
    19e2:	80 83       	st	Z, r24
    19e4:	fe 01       	movw	r30, r28
    19e6:	e0 5b       	subi	r30, 0xB0	; 176
    19e8:	ff 4f       	sbci	r31, 0xFF	; 255
    19ea:	82 e0       	ldi	r24, 0x02	; 2
    19ec:	81 83       	std	Z+1, r24	; 0x01
	TWI_init(&TWI_Config);
    19ee:	ce 01       	movw	r24, r28
    19f0:	80 5b       	subi	r24, 0xB0	; 176
    19f2:	9f 4f       	sbci	r25, 0xFF	; 255
    19f4:	0e 94 b3 07 	call	0xf66	; 0xf66 <TWI_init>
	Buzzer_init();
    19f8:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <Buzzer_init>
	DcMotor_Init();
    19fc:	0e 94 18 0c 	call	0x1830	; 0x1830 <DcMotor_Init>

	while (1) {

		receive2pass_UART(userPass1,userPass2);
    1a00:	ce 01       	movw	r24, r28
    1a02:	cc 96       	adiw	r24, 0x3c	; 60
    1a04:	9e 01       	movw	r18, r28
    1a06:	2f 5b       	subi	r18, 0xBF	; 191
    1a08:	3f 4f       	sbci	r19, 0xFF	; 255
    1a0a:	b9 01       	movw	r22, r18
    1a0c:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <receive2pass_UART>
    1a10:	80 e0       	ldi	r24, 0x00	; 0
    1a12:	90 e0       	ldi	r25, 0x00	; 0
    1a14:	a6 e9       	ldi	r26, 0x96	; 150
    1a16:	b3 e4       	ldi	r27, 0x43	; 67
    1a18:	8d ab       	std	Y+53, r24	; 0x35
    1a1a:	9e ab       	std	Y+54, r25	; 0x36
    1a1c:	af ab       	std	Y+55, r26	; 0x37
    1a1e:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1a20:	6d a9       	ldd	r22, Y+53	; 0x35
    1a22:	7e a9       	ldd	r23, Y+54	; 0x36
    1a24:	8f a9       	ldd	r24, Y+55	; 0x37
    1a26:	98 ad       	ldd	r25, Y+56	; 0x38
    1a28:	20 e0       	ldi	r18, 0x00	; 0
    1a2a:	30 e0       	ldi	r19, 0x00	; 0
    1a2c:	4a ef       	ldi	r20, 0xFA	; 250
    1a2e:	54 e4       	ldi	r21, 0x44	; 68
    1a30:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a34:	dc 01       	movw	r26, r24
    1a36:	cb 01       	movw	r24, r22
    1a38:	89 ab       	std	Y+49, r24	; 0x31
    1a3a:	9a ab       	std	Y+50, r25	; 0x32
    1a3c:	ab ab       	std	Y+51, r26	; 0x33
    1a3e:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    1a40:	69 a9       	ldd	r22, Y+49	; 0x31
    1a42:	7a a9       	ldd	r23, Y+50	; 0x32
    1a44:	8b a9       	ldd	r24, Y+51	; 0x33
    1a46:	9c a9       	ldd	r25, Y+52	; 0x34
    1a48:	20 e0       	ldi	r18, 0x00	; 0
    1a4a:	30 e0       	ldi	r19, 0x00	; 0
    1a4c:	40 e8       	ldi	r20, 0x80	; 128
    1a4e:	5f e3       	ldi	r21, 0x3F	; 63
    1a50:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1a54:	88 23       	and	r24, r24
    1a56:	2c f4       	brge	.+10     	; 0x1a62 <main+0x120>
		__ticks = 1;
    1a58:	81 e0       	ldi	r24, 0x01	; 1
    1a5a:	90 e0       	ldi	r25, 0x00	; 0
    1a5c:	98 ab       	std	Y+48, r25	; 0x30
    1a5e:	8f a7       	std	Y+47, r24	; 0x2f
    1a60:	3f c0       	rjmp	.+126    	; 0x1ae0 <main+0x19e>
	else if (__tmp > 65535)
    1a62:	69 a9       	ldd	r22, Y+49	; 0x31
    1a64:	7a a9       	ldd	r23, Y+50	; 0x32
    1a66:	8b a9       	ldd	r24, Y+51	; 0x33
    1a68:	9c a9       	ldd	r25, Y+52	; 0x34
    1a6a:	20 e0       	ldi	r18, 0x00	; 0
    1a6c:	3f ef       	ldi	r19, 0xFF	; 255
    1a6e:	4f e7       	ldi	r20, 0x7F	; 127
    1a70:	57 e4       	ldi	r21, 0x47	; 71
    1a72:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1a76:	18 16       	cp	r1, r24
    1a78:	4c f5       	brge	.+82     	; 0x1acc <main+0x18a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1a7a:	6d a9       	ldd	r22, Y+53	; 0x35
    1a7c:	7e a9       	ldd	r23, Y+54	; 0x36
    1a7e:	8f a9       	ldd	r24, Y+55	; 0x37
    1a80:	98 ad       	ldd	r25, Y+56	; 0x38
    1a82:	20 e0       	ldi	r18, 0x00	; 0
    1a84:	30 e0       	ldi	r19, 0x00	; 0
    1a86:	40 e2       	ldi	r20, 0x20	; 32
    1a88:	51 e4       	ldi	r21, 0x41	; 65
    1a8a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a8e:	dc 01       	movw	r26, r24
    1a90:	cb 01       	movw	r24, r22
    1a92:	bc 01       	movw	r22, r24
    1a94:	cd 01       	movw	r24, r26
    1a96:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a9a:	dc 01       	movw	r26, r24
    1a9c:	cb 01       	movw	r24, r22
    1a9e:	98 ab       	std	Y+48, r25	; 0x30
    1aa0:	8f a7       	std	Y+47, r24	; 0x2f
    1aa2:	0f c0       	rjmp	.+30     	; 0x1ac2 <main+0x180>
    1aa4:	88 ec       	ldi	r24, 0xC8	; 200
    1aa6:	90 e0       	ldi	r25, 0x00	; 0
    1aa8:	9e a7       	std	Y+46, r25	; 0x2e
    1aaa:	8d a7       	std	Y+45, r24	; 0x2d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1aac:	8d a5       	ldd	r24, Y+45	; 0x2d
    1aae:	9e a5       	ldd	r25, Y+46	; 0x2e
    1ab0:	01 97       	sbiw	r24, 0x01	; 1
    1ab2:	f1 f7       	brne	.-4      	; 0x1ab0 <main+0x16e>
    1ab4:	9e a7       	std	Y+46, r25	; 0x2e
    1ab6:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1ab8:	8f a5       	ldd	r24, Y+47	; 0x2f
    1aba:	98 a9       	ldd	r25, Y+48	; 0x30
    1abc:	01 97       	sbiw	r24, 0x01	; 1
    1abe:	98 ab       	std	Y+48, r25	; 0x30
    1ac0:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1ac2:	8f a5       	ldd	r24, Y+47	; 0x2f
    1ac4:	98 a9       	ldd	r25, Y+48	; 0x30
    1ac6:	00 97       	sbiw	r24, 0x00	; 0
    1ac8:	69 f7       	brne	.-38     	; 0x1aa4 <main+0x162>
    1aca:	14 c0       	rjmp	.+40     	; 0x1af4 <main+0x1b2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1acc:	69 a9       	ldd	r22, Y+49	; 0x31
    1ace:	7a a9       	ldd	r23, Y+50	; 0x32
    1ad0:	8b a9       	ldd	r24, Y+51	; 0x33
    1ad2:	9c a9       	ldd	r25, Y+52	; 0x34
    1ad4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ad8:	dc 01       	movw	r26, r24
    1ada:	cb 01       	movw	r24, r22
    1adc:	98 ab       	std	Y+48, r25	; 0x30
    1ade:	8f a7       	std	Y+47, r24	; 0x2f
    1ae0:	8f a5       	ldd	r24, Y+47	; 0x2f
    1ae2:	98 a9       	ldd	r25, Y+48	; 0x30
    1ae4:	9c a7       	std	Y+44, r25	; 0x2c
    1ae6:	8b a7       	std	Y+43, r24	; 0x2b
    1ae8:	8b a5       	ldd	r24, Y+43	; 0x2b
    1aea:	9c a5       	ldd	r25, Y+44	; 0x2c
    1aec:	01 97       	sbiw	r24, 0x01	; 1
    1aee:	f1 f7       	brne	.-4      	; 0x1aec <main+0x1aa>
    1af0:	9c a7       	std	Y+44, r25	; 0x2c
    1af2:	8b a7       	std	Y+43, r24	; 0x2b
		_delay_ms(300);
		uint8 comp_result = Compare_PASS(userPass1,userPass2,savedPass);
    1af4:	ce 01       	movw	r24, r28
    1af6:	cc 96       	adiw	r24, 0x3c	; 60
    1af8:	9e 01       	movw	r18, r28
    1afa:	2f 5b       	subi	r18, 0xBF	; 191
    1afc:	3f 4f       	sbci	r19, 0xFF	; 255
    1afe:	ae 01       	movw	r20, r28
    1b00:	4a 5b       	subi	r20, 0xBA	; 186
    1b02:	5f 4f       	sbci	r21, 0xFF	; 255
    1b04:	b9 01       	movw	r22, r18
    1b06:	0e 94 63 10 	call	0x20c6	; 0x20c6 <Compare_PASS>
    1b0a:	8b af       	std	Y+59, r24	; 0x3b
    1b0c:	80 e0       	ldi	r24, 0x00	; 0
    1b0e:	90 e0       	ldi	r25, 0x00	; 0
    1b10:	aa ef       	ldi	r26, 0xFA	; 250
    1b12:	b3 e4       	ldi	r27, 0x43	; 67
    1b14:	8f a3       	std	Y+39, r24	; 0x27
    1b16:	98 a7       	std	Y+40, r25	; 0x28
    1b18:	a9 a7       	std	Y+41, r26	; 0x29
    1b1a:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1b1c:	6f a1       	ldd	r22, Y+39	; 0x27
    1b1e:	78 a5       	ldd	r23, Y+40	; 0x28
    1b20:	89 a5       	ldd	r24, Y+41	; 0x29
    1b22:	9a a5       	ldd	r25, Y+42	; 0x2a
    1b24:	20 e0       	ldi	r18, 0x00	; 0
    1b26:	30 e0       	ldi	r19, 0x00	; 0
    1b28:	4a ef       	ldi	r20, 0xFA	; 250
    1b2a:	54 e4       	ldi	r21, 0x44	; 68
    1b2c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b30:	dc 01       	movw	r26, r24
    1b32:	cb 01       	movw	r24, r22
    1b34:	8b a3       	std	Y+35, r24	; 0x23
    1b36:	9c a3       	std	Y+36, r25	; 0x24
    1b38:	ad a3       	std	Y+37, r26	; 0x25
    1b3a:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1b3c:	6b a1       	ldd	r22, Y+35	; 0x23
    1b3e:	7c a1       	ldd	r23, Y+36	; 0x24
    1b40:	8d a1       	ldd	r24, Y+37	; 0x25
    1b42:	9e a1       	ldd	r25, Y+38	; 0x26
    1b44:	20 e0       	ldi	r18, 0x00	; 0
    1b46:	30 e0       	ldi	r19, 0x00	; 0
    1b48:	40 e8       	ldi	r20, 0x80	; 128
    1b4a:	5f e3       	ldi	r21, 0x3F	; 63
    1b4c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1b50:	88 23       	and	r24, r24
    1b52:	2c f4       	brge	.+10     	; 0x1b5e <main+0x21c>
		__ticks = 1;
    1b54:	81 e0       	ldi	r24, 0x01	; 1
    1b56:	90 e0       	ldi	r25, 0x00	; 0
    1b58:	9a a3       	std	Y+34, r25	; 0x22
    1b5a:	89 a3       	std	Y+33, r24	; 0x21
    1b5c:	3f c0       	rjmp	.+126    	; 0x1bdc <main+0x29a>
	else if (__tmp > 65535)
    1b5e:	6b a1       	ldd	r22, Y+35	; 0x23
    1b60:	7c a1       	ldd	r23, Y+36	; 0x24
    1b62:	8d a1       	ldd	r24, Y+37	; 0x25
    1b64:	9e a1       	ldd	r25, Y+38	; 0x26
    1b66:	20 e0       	ldi	r18, 0x00	; 0
    1b68:	3f ef       	ldi	r19, 0xFF	; 255
    1b6a:	4f e7       	ldi	r20, 0x7F	; 127
    1b6c:	57 e4       	ldi	r21, 0x47	; 71
    1b6e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1b72:	18 16       	cp	r1, r24
    1b74:	4c f5       	brge	.+82     	; 0x1bc8 <main+0x286>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1b76:	6f a1       	ldd	r22, Y+39	; 0x27
    1b78:	78 a5       	ldd	r23, Y+40	; 0x28
    1b7a:	89 a5       	ldd	r24, Y+41	; 0x29
    1b7c:	9a a5       	ldd	r25, Y+42	; 0x2a
    1b7e:	20 e0       	ldi	r18, 0x00	; 0
    1b80:	30 e0       	ldi	r19, 0x00	; 0
    1b82:	40 e2       	ldi	r20, 0x20	; 32
    1b84:	51 e4       	ldi	r21, 0x41	; 65
    1b86:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b8a:	dc 01       	movw	r26, r24
    1b8c:	cb 01       	movw	r24, r22
    1b8e:	bc 01       	movw	r22, r24
    1b90:	cd 01       	movw	r24, r26
    1b92:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1b96:	dc 01       	movw	r26, r24
    1b98:	cb 01       	movw	r24, r22
    1b9a:	9a a3       	std	Y+34, r25	; 0x22
    1b9c:	89 a3       	std	Y+33, r24	; 0x21
    1b9e:	0f c0       	rjmp	.+30     	; 0x1bbe <main+0x27c>
    1ba0:	88 ec       	ldi	r24, 0xC8	; 200
    1ba2:	90 e0       	ldi	r25, 0x00	; 0
    1ba4:	98 a3       	std	Y+32, r25	; 0x20
    1ba6:	8f 8f       	std	Y+31, r24	; 0x1f
    1ba8:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1baa:	98 a1       	ldd	r25, Y+32	; 0x20
    1bac:	01 97       	sbiw	r24, 0x01	; 1
    1bae:	f1 f7       	brne	.-4      	; 0x1bac <main+0x26a>
    1bb0:	98 a3       	std	Y+32, r25	; 0x20
    1bb2:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1bb4:	89 a1       	ldd	r24, Y+33	; 0x21
    1bb6:	9a a1       	ldd	r25, Y+34	; 0x22
    1bb8:	01 97       	sbiw	r24, 0x01	; 1
    1bba:	9a a3       	std	Y+34, r25	; 0x22
    1bbc:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1bbe:	89 a1       	ldd	r24, Y+33	; 0x21
    1bc0:	9a a1       	ldd	r25, Y+34	; 0x22
    1bc2:	00 97       	sbiw	r24, 0x00	; 0
    1bc4:	69 f7       	brne	.-38     	; 0x1ba0 <main+0x25e>
    1bc6:	14 c0       	rjmp	.+40     	; 0x1bf0 <main+0x2ae>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1bc8:	6b a1       	ldd	r22, Y+35	; 0x23
    1bca:	7c a1       	ldd	r23, Y+36	; 0x24
    1bcc:	8d a1       	ldd	r24, Y+37	; 0x25
    1bce:	9e a1       	ldd	r25, Y+38	; 0x26
    1bd0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1bd4:	dc 01       	movw	r26, r24
    1bd6:	cb 01       	movw	r24, r22
    1bd8:	9a a3       	std	Y+34, r25	; 0x22
    1bda:	89 a3       	std	Y+33, r24	; 0x21
    1bdc:	89 a1       	ldd	r24, Y+33	; 0x21
    1bde:	9a a1       	ldd	r25, Y+34	; 0x22
    1be0:	9e 8f       	std	Y+30, r25	; 0x1e
    1be2:	8d 8f       	std	Y+29, r24	; 0x1d
    1be4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1be6:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1be8:	01 97       	sbiw	r24, 0x01	; 1
    1bea:	f1 f7       	brne	.-4      	; 0x1be8 <main+0x2a6>
    1bec:	9e 8f       	std	Y+30, r25	; 0x1e
    1bee:	8d 8f       	std	Y+29, r24	; 0x1d
		_delay_ms(500);

		switch(comp_result)
    1bf0:	8b ad       	ldd	r24, Y+59	; 0x3b
    1bf2:	e8 2f       	mov	r30, r24
    1bf4:	f0 e0       	ldi	r31, 0x00	; 0
    1bf6:	64 96       	adiw	r28, 0x14	; 20
    1bf8:	ff af       	std	Y+63, r31	; 0x3f
    1bfa:	ee af       	std	Y+62, r30	; 0x3e
    1bfc:	64 97       	sbiw	r28, 0x14	; 20
    1bfe:	64 96       	adiw	r28, 0x14	; 20
    1c00:	2e ad       	ldd	r18, Y+62	; 0x3e
    1c02:	3f ad       	ldd	r19, Y+63	; 0x3f
    1c04:	64 97       	sbiw	r28, 0x14	; 20
    1c06:	21 30       	cpi	r18, 0x01	; 1
    1c08:	31 05       	cpc	r19, r1
    1c0a:	09 f4       	brne	.+2      	; 0x1c0e <main+0x2cc>
    1c0c:	1d c1       	rjmp	.+570    	; 0x1e48 <main+0x506>
    1c0e:	64 96       	adiw	r28, 0x14	; 20
    1c10:	8e ad       	ldd	r24, Y+62	; 0x3e
    1c12:	9f ad       	ldd	r25, Y+63	; 0x3f
    1c14:	64 97       	sbiw	r28, 0x14	; 20
    1c16:	82 30       	cpi	r24, 0x02	; 2
    1c18:	91 05       	cpc	r25, r1
    1c1a:	09 f0       	breq	.+2      	; 0x1c1e <main+0x2dc>
    1c1c:	f1 ce       	rjmp	.-542    	; 0x1a00 <main+0xbe>
		{
			case CORRECT_PASSWORD:
					storePass(savedPass);
    1c1e:	ce 01       	movw	r24, r28
    1c20:	8a 5b       	subi	r24, 0xBA	; 186
    1c22:	9f 4f       	sbci	r25, 0xFF	; 255
    1c24:	0e 94 f6 11 	call	0x23ec	; 0x23ec <storePass>
    1c28:	04 c1       	rjmp	.+520    	; 0x1e32 <main+0x4f0>
					while(remaining_trials>0 && break_cond)
					{
						UART_sendByte(SELECTING_OPTION);
    1c2a:	86 e0       	ldi	r24, 0x06	; 6
    1c2c:	0e 94 f1 06 	call	0xde2	; 0xde2 <UART_sendByte>
						uint8 option = UART_recieveByte();
    1c30:	0e 94 08 07 	call	0xe10	; 0xe10 <UART_recieveByte>
    1c34:	8a af       	std	Y+58, r24	; 0x3a
    1c36:	80 e0       	ldi	r24, 0x00	; 0
    1c38:	90 e0       	ldi	r25, 0x00	; 0
    1c3a:	a0 e7       	ldi	r26, 0x70	; 112
    1c3c:	b1 e4       	ldi	r27, 0x41	; 65
    1c3e:	89 8f       	std	Y+25, r24	; 0x19
    1c40:	9a 8f       	std	Y+26, r25	; 0x1a
    1c42:	ab 8f       	std	Y+27, r26	; 0x1b
    1c44:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1c46:	69 8d       	ldd	r22, Y+25	; 0x19
    1c48:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1c4a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1c4c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1c4e:	20 e0       	ldi	r18, 0x00	; 0
    1c50:	30 e0       	ldi	r19, 0x00	; 0
    1c52:	4a ef       	ldi	r20, 0xFA	; 250
    1c54:	54 e4       	ldi	r21, 0x44	; 68
    1c56:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1c5a:	dc 01       	movw	r26, r24
    1c5c:	cb 01       	movw	r24, r22
    1c5e:	8d 8b       	std	Y+21, r24	; 0x15
    1c60:	9e 8b       	std	Y+22, r25	; 0x16
    1c62:	af 8b       	std	Y+23, r26	; 0x17
    1c64:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1c66:	6d 89       	ldd	r22, Y+21	; 0x15
    1c68:	7e 89       	ldd	r23, Y+22	; 0x16
    1c6a:	8f 89       	ldd	r24, Y+23	; 0x17
    1c6c:	98 8d       	ldd	r25, Y+24	; 0x18
    1c6e:	20 e0       	ldi	r18, 0x00	; 0
    1c70:	30 e0       	ldi	r19, 0x00	; 0
    1c72:	40 e8       	ldi	r20, 0x80	; 128
    1c74:	5f e3       	ldi	r21, 0x3F	; 63
    1c76:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1c7a:	88 23       	and	r24, r24
    1c7c:	2c f4       	brge	.+10     	; 0x1c88 <main+0x346>
		__ticks = 1;
    1c7e:	81 e0       	ldi	r24, 0x01	; 1
    1c80:	90 e0       	ldi	r25, 0x00	; 0
    1c82:	9c 8b       	std	Y+20, r25	; 0x14
    1c84:	8b 8b       	std	Y+19, r24	; 0x13
    1c86:	3f c0       	rjmp	.+126    	; 0x1d06 <main+0x3c4>
	else if (__tmp > 65535)
    1c88:	6d 89       	ldd	r22, Y+21	; 0x15
    1c8a:	7e 89       	ldd	r23, Y+22	; 0x16
    1c8c:	8f 89       	ldd	r24, Y+23	; 0x17
    1c8e:	98 8d       	ldd	r25, Y+24	; 0x18
    1c90:	20 e0       	ldi	r18, 0x00	; 0
    1c92:	3f ef       	ldi	r19, 0xFF	; 255
    1c94:	4f e7       	ldi	r20, 0x7F	; 127
    1c96:	57 e4       	ldi	r21, 0x47	; 71
    1c98:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1c9c:	18 16       	cp	r1, r24
    1c9e:	4c f5       	brge	.+82     	; 0x1cf2 <main+0x3b0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1ca0:	69 8d       	ldd	r22, Y+25	; 0x19
    1ca2:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1ca4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1ca6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1ca8:	20 e0       	ldi	r18, 0x00	; 0
    1caa:	30 e0       	ldi	r19, 0x00	; 0
    1cac:	40 e2       	ldi	r20, 0x20	; 32
    1cae:	51 e4       	ldi	r21, 0x41	; 65
    1cb0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1cb4:	dc 01       	movw	r26, r24
    1cb6:	cb 01       	movw	r24, r22
    1cb8:	bc 01       	movw	r22, r24
    1cba:	cd 01       	movw	r24, r26
    1cbc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1cc0:	dc 01       	movw	r26, r24
    1cc2:	cb 01       	movw	r24, r22
    1cc4:	9c 8b       	std	Y+20, r25	; 0x14
    1cc6:	8b 8b       	std	Y+19, r24	; 0x13
    1cc8:	0f c0       	rjmp	.+30     	; 0x1ce8 <main+0x3a6>
    1cca:	88 ec       	ldi	r24, 0xC8	; 200
    1ccc:	90 e0       	ldi	r25, 0x00	; 0
    1cce:	9a 8b       	std	Y+18, r25	; 0x12
    1cd0:	89 8b       	std	Y+17, r24	; 0x11
    1cd2:	89 89       	ldd	r24, Y+17	; 0x11
    1cd4:	9a 89       	ldd	r25, Y+18	; 0x12
    1cd6:	01 97       	sbiw	r24, 0x01	; 1
    1cd8:	f1 f7       	brne	.-4      	; 0x1cd6 <main+0x394>
    1cda:	9a 8b       	std	Y+18, r25	; 0x12
    1cdc:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1cde:	8b 89       	ldd	r24, Y+19	; 0x13
    1ce0:	9c 89       	ldd	r25, Y+20	; 0x14
    1ce2:	01 97       	sbiw	r24, 0x01	; 1
    1ce4:	9c 8b       	std	Y+20, r25	; 0x14
    1ce6:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1ce8:	8b 89       	ldd	r24, Y+19	; 0x13
    1cea:	9c 89       	ldd	r25, Y+20	; 0x14
    1cec:	00 97       	sbiw	r24, 0x00	; 0
    1cee:	69 f7       	brne	.-38     	; 0x1cca <main+0x388>
    1cf0:	14 c0       	rjmp	.+40     	; 0x1d1a <main+0x3d8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1cf2:	6d 89       	ldd	r22, Y+21	; 0x15
    1cf4:	7e 89       	ldd	r23, Y+22	; 0x16
    1cf6:	8f 89       	ldd	r24, Y+23	; 0x17
    1cf8:	98 8d       	ldd	r25, Y+24	; 0x18
    1cfa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1cfe:	dc 01       	movw	r26, r24
    1d00:	cb 01       	movw	r24, r22
    1d02:	9c 8b       	std	Y+20, r25	; 0x14
    1d04:	8b 8b       	std	Y+19, r24	; 0x13
    1d06:	8b 89       	ldd	r24, Y+19	; 0x13
    1d08:	9c 89       	ldd	r25, Y+20	; 0x14
    1d0a:	98 8b       	std	Y+16, r25	; 0x10
    1d0c:	8f 87       	std	Y+15, r24	; 0x0f
    1d0e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1d10:	98 89       	ldd	r25, Y+16	; 0x10
    1d12:	01 97       	sbiw	r24, 0x01	; 1
    1d14:	f1 f7       	brne	.-4      	; 0x1d12 <main+0x3d0>
    1d16:	98 8b       	std	Y+16, r25	; 0x10
    1d18:	8f 87       	std	Y+15, r24	; 0x0f
						_delay_ms(15);
						Receive_PASS(userPass1);
    1d1a:	ce 01       	movw	r24, r28
    1d1c:	cc 96       	adiw	r24, 0x3c	; 60
    1d1e:	0e 94 01 13 	call	0x2602	; 0x2602 <Receive_PASS>
    1d22:	80 e0       	ldi	r24, 0x00	; 0
    1d24:	90 e0       	ldi	r25, 0x00	; 0
    1d26:	aa ef       	ldi	r26, 0xFA	; 250
    1d28:	b3 e4       	ldi	r27, 0x43	; 67
    1d2a:	8b 87       	std	Y+11, r24	; 0x0b
    1d2c:	9c 87       	std	Y+12, r25	; 0x0c
    1d2e:	ad 87       	std	Y+13, r26	; 0x0d
    1d30:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1d32:	6b 85       	ldd	r22, Y+11	; 0x0b
    1d34:	7c 85       	ldd	r23, Y+12	; 0x0c
    1d36:	8d 85       	ldd	r24, Y+13	; 0x0d
    1d38:	9e 85       	ldd	r25, Y+14	; 0x0e
    1d3a:	20 e0       	ldi	r18, 0x00	; 0
    1d3c:	30 e0       	ldi	r19, 0x00	; 0
    1d3e:	4a ef       	ldi	r20, 0xFA	; 250
    1d40:	54 e4       	ldi	r21, 0x44	; 68
    1d42:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1d46:	dc 01       	movw	r26, r24
    1d48:	cb 01       	movw	r24, r22
    1d4a:	8f 83       	std	Y+7, r24	; 0x07
    1d4c:	98 87       	std	Y+8, r25	; 0x08
    1d4e:	a9 87       	std	Y+9, r26	; 0x09
    1d50:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1d52:	6f 81       	ldd	r22, Y+7	; 0x07
    1d54:	78 85       	ldd	r23, Y+8	; 0x08
    1d56:	89 85       	ldd	r24, Y+9	; 0x09
    1d58:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d5a:	20 e0       	ldi	r18, 0x00	; 0
    1d5c:	30 e0       	ldi	r19, 0x00	; 0
    1d5e:	40 e8       	ldi	r20, 0x80	; 128
    1d60:	5f e3       	ldi	r21, 0x3F	; 63
    1d62:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1d66:	88 23       	and	r24, r24
    1d68:	2c f4       	brge	.+10     	; 0x1d74 <main+0x432>
		__ticks = 1;
    1d6a:	81 e0       	ldi	r24, 0x01	; 1
    1d6c:	90 e0       	ldi	r25, 0x00	; 0
    1d6e:	9e 83       	std	Y+6, r25	; 0x06
    1d70:	8d 83       	std	Y+5, r24	; 0x05
    1d72:	3f c0       	rjmp	.+126    	; 0x1df2 <main+0x4b0>
	else if (__tmp > 65535)
    1d74:	6f 81       	ldd	r22, Y+7	; 0x07
    1d76:	78 85       	ldd	r23, Y+8	; 0x08
    1d78:	89 85       	ldd	r24, Y+9	; 0x09
    1d7a:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d7c:	20 e0       	ldi	r18, 0x00	; 0
    1d7e:	3f ef       	ldi	r19, 0xFF	; 255
    1d80:	4f e7       	ldi	r20, 0x7F	; 127
    1d82:	57 e4       	ldi	r21, 0x47	; 71
    1d84:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1d88:	18 16       	cp	r1, r24
    1d8a:	4c f5       	brge	.+82     	; 0x1dde <main+0x49c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1d8c:	6b 85       	ldd	r22, Y+11	; 0x0b
    1d8e:	7c 85       	ldd	r23, Y+12	; 0x0c
    1d90:	8d 85       	ldd	r24, Y+13	; 0x0d
    1d92:	9e 85       	ldd	r25, Y+14	; 0x0e
    1d94:	20 e0       	ldi	r18, 0x00	; 0
    1d96:	30 e0       	ldi	r19, 0x00	; 0
    1d98:	40 e2       	ldi	r20, 0x20	; 32
    1d9a:	51 e4       	ldi	r21, 0x41	; 65
    1d9c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1da0:	dc 01       	movw	r26, r24
    1da2:	cb 01       	movw	r24, r22
    1da4:	bc 01       	movw	r22, r24
    1da6:	cd 01       	movw	r24, r26
    1da8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1dac:	dc 01       	movw	r26, r24
    1dae:	cb 01       	movw	r24, r22
    1db0:	9e 83       	std	Y+6, r25	; 0x06
    1db2:	8d 83       	std	Y+5, r24	; 0x05
    1db4:	0f c0       	rjmp	.+30     	; 0x1dd4 <main+0x492>
    1db6:	88 ec       	ldi	r24, 0xC8	; 200
    1db8:	90 e0       	ldi	r25, 0x00	; 0
    1dba:	9c 83       	std	Y+4, r25	; 0x04
    1dbc:	8b 83       	std	Y+3, r24	; 0x03
    1dbe:	8b 81       	ldd	r24, Y+3	; 0x03
    1dc0:	9c 81       	ldd	r25, Y+4	; 0x04
    1dc2:	01 97       	sbiw	r24, 0x01	; 1
    1dc4:	f1 f7       	brne	.-4      	; 0x1dc2 <main+0x480>
    1dc6:	9c 83       	std	Y+4, r25	; 0x04
    1dc8:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1dca:	8d 81       	ldd	r24, Y+5	; 0x05
    1dcc:	9e 81       	ldd	r25, Y+6	; 0x06
    1dce:	01 97       	sbiw	r24, 0x01	; 1
    1dd0:	9e 83       	std	Y+6, r25	; 0x06
    1dd2:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1dd4:	8d 81       	ldd	r24, Y+5	; 0x05
    1dd6:	9e 81       	ldd	r25, Y+6	; 0x06
    1dd8:	00 97       	sbiw	r24, 0x00	; 0
    1dda:	69 f7       	brne	.-38     	; 0x1db6 <main+0x474>
    1ddc:	14 c0       	rjmp	.+40     	; 0x1e06 <main+0x4c4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1dde:	6f 81       	ldd	r22, Y+7	; 0x07
    1de0:	78 85       	ldd	r23, Y+8	; 0x08
    1de2:	89 85       	ldd	r24, Y+9	; 0x09
    1de4:	9a 85       	ldd	r25, Y+10	; 0x0a
    1de6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1dea:	dc 01       	movw	r26, r24
    1dec:	cb 01       	movw	r24, r22
    1dee:	9e 83       	std	Y+6, r25	; 0x06
    1df0:	8d 83       	std	Y+5, r24	; 0x05
    1df2:	8d 81       	ldd	r24, Y+5	; 0x05
    1df4:	9e 81       	ldd	r25, Y+6	; 0x06
    1df6:	9a 83       	std	Y+2, r25	; 0x02
    1df8:	89 83       	std	Y+1, r24	; 0x01
    1dfa:	89 81       	ldd	r24, Y+1	; 0x01
    1dfc:	9a 81       	ldd	r25, Y+2	; 0x02
    1dfe:	01 97       	sbiw	r24, 0x01	; 1
    1e00:	f1 f7       	brne	.-4      	; 0x1dfe <main+0x4bc>
    1e02:	9a 83       	std	Y+2, r25	; 0x02
    1e04:	89 83       	std	Y+1, r24	; 0x01
						_delay_ms(500);

						/* saves compare result state bet. entered & saved pass in eeprom */
						uint8 pass_resultState = Compare_savedPass(userPass1,savedPass);
    1e06:	ce 01       	movw	r24, r28
    1e08:	cc 96       	adiw	r24, 0x3c	; 60
    1e0a:	9e 01       	movw	r18, r28
    1e0c:	2a 5b       	subi	r18, 0xBA	; 186
    1e0e:	3f 4f       	sbci	r19, 0xFF	; 255
    1e10:	b9 01       	movw	r22, r18
    1e12:	0e 94 a3 13 	call	0x2746	; 0x2746 <Compare_savedPass>
    1e16:	89 af       	std	Y+57, r24	; 0x39
						if(option == DOOR_CONTROL)
    1e18:	8a ad       	ldd	r24, Y+58	; 0x3a
    1e1a:	87 30       	cpi	r24, 0x07	; 7
    1e1c:	21 f4       	brne	.+8      	; 0x1e26 <main+0x4e4>
						{
							handlePlusOption(pass_resultState);
    1e1e:	89 ad       	ldd	r24, Y+57	; 0x39
    1e20:	0e 94 c2 14 	call	0x2984	; 0x2984 <handlePlusOption>
    1e24:	06 c0       	rjmp	.+12     	; 0x1e32 <main+0x4f0>
						}
						else if (option == PASSWORD_CHANGE)
    1e26:	8a ad       	ldd	r24, Y+58	; 0x3a
    1e28:	88 30       	cpi	r24, 0x08	; 8
    1e2a:	19 f4       	brne	.+6      	; 0x1e32 <main+0x4f0>
						{
							handleMinusOption(pass_resultState);
    1e2c:	89 ad       	ldd	r24, Y+57	; 0x39
    1e2e:	0e 94 06 15 	call	0x2a0c	; 0x2a0c <handleMinusOption>

		switch(comp_result)
		{
			case CORRECT_PASSWORD:
					storePass(savedPass);
					while(remaining_trials>0 && break_cond)
    1e32:	80 91 68 00 	lds	r24, 0x0068
    1e36:	88 23       	and	r24, r24
    1e38:	09 f4       	brne	.+2      	; 0x1e3c <main+0x4fa>
    1e3a:	e2 cd       	rjmp	.-1084   	; 0x1a00 <main+0xbe>
    1e3c:	80 91 69 00 	lds	r24, 0x0069
    1e40:	88 23       	and	r24, r24
    1e42:	09 f0       	breq	.+2      	; 0x1e46 <main+0x504>
    1e44:	f2 ce       	rjmp	.-540    	; 0x1c2a <main+0x2e8>
    1e46:	dc cd       	rjmp	.-1096   	; 0x1a00 <main+0xbe>
						}
					}
					break;

			 case INCORRECT_PASSWORD:
					while (UART_recieveByte() != CHECKING_PASSWORD);
    1e48:	0e 94 08 07 	call	0xe10	; 0xe10 <UART_recieveByte>
    1e4c:	84 30       	cpi	r24, 0x04	; 4
    1e4e:	e1 f7       	brne	.-8      	; 0x1e48 <main+0x506>
					UART_sendByte(INCORRECT_PASSWORD);
    1e50:	81 e0       	ldi	r24, 0x01	; 1
    1e52:	0e 94 f1 06 	call	0xde2	; 0xde2 <UART_sendByte>
    1e56:	d4 cd       	rjmp	.-1112   	; 0x1a00 <main+0xbe>

00001e58 <doorLocker>:

/*
 * System features functions to toggle alarm & run motor
 */
void doorLocker(void)
{
    1e58:	df 93       	push	r29
    1e5a:	cf 93       	push	r28
    1e5c:	cd b7       	in	r28, 0x3d	; 61
    1e5e:	de b7       	in	r29, 0x3e	; 62
		DcMotor_Rotate(CW, 100);
    1e60:	81 e0       	ldi	r24, 0x01	; 1
    1e62:	64 e6       	ldi	r22, 0x64	; 100
    1e64:	0e 94 33 0c 	call	0x1866	; 0x1866 <DcMotor_Rotate>
		delaySeconds(CW_sec);
    1e68:	8f e0       	ldi	r24, 0x0F	; 15
    1e6a:	0e 94 66 0f 	call	0x1ecc	; 0x1ecc <delaySeconds>

		DcMotor_Rotate(STOP, 0);
    1e6e:	80 e0       	ldi	r24, 0x00	; 0
    1e70:	60 e0       	ldi	r22, 0x00	; 0
    1e72:	0e 94 33 0c 	call	0x1866	; 0x1866 <DcMotor_Rotate>
		delaySeconds(WAIT_sec);
    1e76:	83 e0       	ldi	r24, 0x03	; 3
    1e78:	0e 94 66 0f 	call	0x1ecc	; 0x1ecc <delaySeconds>

		DcMotor_Rotate(A_CW,100);
    1e7c:	82 e0       	ldi	r24, 0x02	; 2
    1e7e:	64 e6       	ldi	r22, 0x64	; 100
    1e80:	0e 94 33 0c 	call	0x1866	; 0x1866 <DcMotor_Rotate>
		delaySeconds(CCW_sec);
    1e84:	8f e0       	ldi	r24, 0x0F	; 15
    1e86:	0e 94 66 0f 	call	0x1ecc	; 0x1ecc <delaySeconds>

		DcMotor_Rotate(STOP, 0);
    1e8a:	80 e0       	ldi	r24, 0x00	; 0
    1e8c:	60 e0       	ldi	r22, 0x00	; 0
    1e8e:	0e 94 33 0c 	call	0x1866	; 0x1866 <DcMotor_Rotate>
}
    1e92:	cf 91       	pop	r28
    1e94:	df 91       	pop	r29
    1e96:	08 95       	ret

00001e98 <Alarm>:

void Alarm(void)
{
    1e98:	df 93       	push	r29
    1e9a:	cf 93       	push	r28
    1e9c:	cd b7       	in	r28, 0x3d	; 61
    1e9e:	de b7       	in	r29, 0x3e	; 62
		Buzzer_on();
    1ea0:	0e 94 89 0c 	call	0x1912	; 0x1912 <Buzzer_on>
		delaySeconds(60);
    1ea4:	8c e3       	ldi	r24, 0x3C	; 60
    1ea6:	0e 94 66 0f 	call	0x1ecc	; 0x1ecc <delaySeconds>
		Buzzer_off();
    1eaa:	0e 94 95 0c 	call	0x192a	; 0x192a <Buzzer_off>
}
    1eae:	cf 91       	pop	r28
    1eb0:	df 91       	pop	r29
    1eb2:	08 95       	ret

00001eb4 <timer1_TickHandler>:

/*
 * Timer1 seconds delay Handler
 */
void timer1_TickHandler(void)
{
    1eb4:	df 93       	push	r29
    1eb6:	cf 93       	push	r28
    1eb8:	cd b7       	in	r28, 0x3d	; 61
    1eba:	de b7       	in	r29, 0x3e	; 62
	ticks++;
    1ebc:	80 91 79 00 	lds	r24, 0x0079
    1ec0:	8f 5f       	subi	r24, 0xFF	; 255
    1ec2:	80 93 79 00 	sts	0x0079, r24
}
    1ec6:	cf 91       	pop	r28
    1ec8:	df 91       	pop	r29
    1eca:	08 95       	ret

00001ecc <delaySeconds>:

void delaySeconds(uint8 seconds)
{
    1ecc:	df 93       	push	r29
    1ece:	cf 93       	push	r28
    1ed0:	cd b7       	in	r28, 0x3d	; 61
    1ed2:	de b7       	in	r29, 0x3e	; 62
    1ed4:	2c 97       	sbiw	r28, 0x0c	; 12
    1ed6:	0f b6       	in	r0, 0x3f	; 63
    1ed8:	f8 94       	cli
    1eda:	de bf       	out	0x3e, r29	; 62
    1edc:	0f be       	out	0x3f, r0	; 63
    1ede:	cd bf       	out	0x3d, r28	; 61
    1ee0:	8f 83       	std	Y+7, r24	; 0x07
	ticks = 0;
    1ee2:	10 92 79 00 	sts	0x0079, r1
	 * Initial Value =0
	 * Prescaler F_CPU/256
	 * Compare mode
	 * Compare value =31250
	 */
	Timer1_ConfigType Timer1_Config = {0,F_CPU_256,COMPARE,31250};
    1ee6:	ce 01       	movw	r24, r28
    1ee8:	01 96       	adiw	r24, 0x01	; 1
    1eea:	99 87       	std	Y+9, r25	; 0x09
    1eec:	88 87       	std	Y+8, r24	; 0x08
    1eee:	ef e6       	ldi	r30, 0x6F	; 111
    1ef0:	f0 e0       	ldi	r31, 0x00	; 0
    1ef2:	fb 87       	std	Y+11, r31	; 0x0b
    1ef4:	ea 87       	std	Y+10, r30	; 0x0a
    1ef6:	f6 e0       	ldi	r31, 0x06	; 6
    1ef8:	fc 87       	std	Y+12, r31	; 0x0c
    1efa:	ea 85       	ldd	r30, Y+10	; 0x0a
    1efc:	fb 85       	ldd	r31, Y+11	; 0x0b
    1efe:	00 80       	ld	r0, Z
    1f00:	8a 85       	ldd	r24, Y+10	; 0x0a
    1f02:	9b 85       	ldd	r25, Y+11	; 0x0b
    1f04:	01 96       	adiw	r24, 0x01	; 1
    1f06:	9b 87       	std	Y+11, r25	; 0x0b
    1f08:	8a 87       	std	Y+10, r24	; 0x0a
    1f0a:	e8 85       	ldd	r30, Y+8	; 0x08
    1f0c:	f9 85       	ldd	r31, Y+9	; 0x09
    1f0e:	00 82       	st	Z, r0
    1f10:	88 85       	ldd	r24, Y+8	; 0x08
    1f12:	99 85       	ldd	r25, Y+9	; 0x09
    1f14:	01 96       	adiw	r24, 0x01	; 1
    1f16:	99 87       	std	Y+9, r25	; 0x09
    1f18:	88 87       	std	Y+8, r24	; 0x08
    1f1a:	9c 85       	ldd	r25, Y+12	; 0x0c
    1f1c:	91 50       	subi	r25, 0x01	; 1
    1f1e:	9c 87       	std	Y+12, r25	; 0x0c
    1f20:	ec 85       	ldd	r30, Y+12	; 0x0c
    1f22:	ee 23       	and	r30, r30
    1f24:	51 f7       	brne	.-44     	; 0x1efa <delaySeconds+0x2e>
	Timer1_init(&Timer1_Config);
    1f26:	ce 01       	movw	r24, r28
    1f28:	01 96       	adiw	r24, 0x01	; 1
    1f2a:	0e 94 0b 06 	call	0xc16	; 0xc16 <Timer1_init>
	Timer1_setCallBack(timer1_TickHandler);
    1f2e:	8a e5       	ldi	r24, 0x5A	; 90
    1f30:	9f e0       	ldi	r25, 0x0F	; 15
    1f32:	0e 94 75 06 	call	0xcea	; 0xcea <Timer1_setCallBack>
	while (ticks != seconds);
    1f36:	90 91 79 00 	lds	r25, 0x0079
    1f3a:	8f 81       	ldd	r24, Y+7	; 0x07
    1f3c:	98 17       	cp	r25, r24
    1f3e:	d9 f7       	brne	.-10     	; 0x1f36 <delaySeconds+0x6a>
	Timer1_deInit();
    1f40:	0e 94 53 06 	call	0xca6	; 0xca6 <Timer1_deInit>
}
    1f44:	2c 96       	adiw	r28, 0x0c	; 12
    1f46:	0f b6       	in	r0, 0x3f	; 63
    1f48:	f8 94       	cli
    1f4a:	de bf       	out	0x3e, r29	; 62
    1f4c:	0f be       	out	0x3f, r0	; 63
    1f4e:	cd bf       	out	0x3d, r28	; 61
    1f50:	cf 91       	pop	r28
    1f52:	df 91       	pop	r29
    1f54:	08 95       	ret

00001f56 <receive2pass_UART>:

/*
 * Receive Passwords and compare them if matching occurs save it
 */
void receive2pass_UART(uint8 *userPass1, uint8 *userPass2)
{
    1f56:	0f 93       	push	r16
    1f58:	1f 93       	push	r17
    1f5a:	df 93       	push	r29
    1f5c:	cf 93       	push	r28
    1f5e:	cd b7       	in	r28, 0x3d	; 61
    1f60:	de b7       	in	r29, 0x3e	; 62
    1f62:	63 97       	sbiw	r28, 0x13	; 19
    1f64:	0f b6       	in	r0, 0x3f	; 63
    1f66:	f8 94       	cli
    1f68:	de bf       	out	0x3e, r29	; 62
    1f6a:	0f be       	out	0x3f, r0	; 63
    1f6c:	cd bf       	out	0x3d, r28	; 61
    1f6e:	99 8b       	std	Y+17, r25	; 0x11
    1f70:	88 8b       	std	Y+16, r24	; 0x10
    1f72:	7b 8b       	std	Y+19, r23	; 0x13
    1f74:	6a 8b       	std	Y+18, r22	; 0x12
	uint8 counter;
	UART_sendByte(SEND_UART);
    1f76:	80 e0       	ldi	r24, 0x00	; 0
    1f78:	0e 94 f1 06 	call	0xde2	; 0xde2 <UART_sendByte>
	for (counter =0;counter<PASS_LENGTH;counter++)
    1f7c:	1f 86       	std	Y+15, r1	; 0x0f
    1f7e:	0f c0       	rjmp	.+30     	; 0x1f9e <receive2pass_UART+0x48>
	{
		 userPass1[counter] =UART_recieveByte();
    1f80:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f82:	28 2f       	mov	r18, r24
    1f84:	30 e0       	ldi	r19, 0x00	; 0
    1f86:	88 89       	ldd	r24, Y+16	; 0x10
    1f88:	99 89       	ldd	r25, Y+17	; 0x11
    1f8a:	8c 01       	movw	r16, r24
    1f8c:	02 0f       	add	r16, r18
    1f8e:	13 1f       	adc	r17, r19
    1f90:	0e 94 08 07 	call	0xe10	; 0xe10 <UART_recieveByte>
    1f94:	f8 01       	movw	r30, r16
    1f96:	80 83       	st	Z, r24
 */
void receive2pass_UART(uint8 *userPass1, uint8 *userPass2)
{
	uint8 counter;
	UART_sendByte(SEND_UART);
	for (counter =0;counter<PASS_LENGTH;counter++)
    1f98:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f9a:	8f 5f       	subi	r24, 0xFF	; 255
    1f9c:	8f 87       	std	Y+15, r24	; 0x0f
    1f9e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1fa0:	85 30       	cpi	r24, 0x05	; 5
    1fa2:	70 f3       	brcs	.-36     	; 0x1f80 <receive2pass_UART+0x2a>
	{
		 userPass1[counter] =UART_recieveByte();
	}
	for (counter =0;counter<PASS_LENGTH;counter++)
    1fa4:	1f 86       	std	Y+15, r1	; 0x0f
    1fa6:	0f c0       	rjmp	.+30     	; 0x1fc6 <receive2pass_UART+0x70>
	{
		 userPass2[counter] =UART_recieveByte();
    1fa8:	8f 85       	ldd	r24, Y+15	; 0x0f
    1faa:	28 2f       	mov	r18, r24
    1fac:	30 e0       	ldi	r19, 0x00	; 0
    1fae:	8a 89       	ldd	r24, Y+18	; 0x12
    1fb0:	9b 89       	ldd	r25, Y+19	; 0x13
    1fb2:	8c 01       	movw	r16, r24
    1fb4:	02 0f       	add	r16, r18
    1fb6:	13 1f       	adc	r17, r19
    1fb8:	0e 94 08 07 	call	0xe10	; 0xe10 <UART_recieveByte>
    1fbc:	f8 01       	movw	r30, r16
    1fbe:	80 83       	st	Z, r24
	UART_sendByte(SEND_UART);
	for (counter =0;counter<PASS_LENGTH;counter++)
	{
		 userPass1[counter] =UART_recieveByte();
	}
	for (counter =0;counter<PASS_LENGTH;counter++)
    1fc0:	8f 85       	ldd	r24, Y+15	; 0x0f
    1fc2:	8f 5f       	subi	r24, 0xFF	; 255
    1fc4:	8f 87       	std	Y+15, r24	; 0x0f
    1fc6:	8f 85       	ldd	r24, Y+15	; 0x0f
    1fc8:	85 30       	cpi	r24, 0x05	; 5
    1fca:	70 f3       	brcs	.-36     	; 0x1fa8 <receive2pass_UART+0x52>
    1fcc:	80 e0       	ldi	r24, 0x00	; 0
    1fce:	90 e0       	ldi	r25, 0x00	; 0
    1fd0:	aa ef       	ldi	r26, 0xFA	; 250
    1fd2:	b3 e4       	ldi	r27, 0x43	; 67
    1fd4:	8b 87       	std	Y+11, r24	; 0x0b
    1fd6:	9c 87       	std	Y+12, r25	; 0x0c
    1fd8:	ad 87       	std	Y+13, r26	; 0x0d
    1fda:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1fdc:	6b 85       	ldd	r22, Y+11	; 0x0b
    1fde:	7c 85       	ldd	r23, Y+12	; 0x0c
    1fe0:	8d 85       	ldd	r24, Y+13	; 0x0d
    1fe2:	9e 85       	ldd	r25, Y+14	; 0x0e
    1fe4:	20 e0       	ldi	r18, 0x00	; 0
    1fe6:	30 e0       	ldi	r19, 0x00	; 0
    1fe8:	4a ef       	ldi	r20, 0xFA	; 250
    1fea:	54 e4       	ldi	r21, 0x44	; 68
    1fec:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1ff0:	dc 01       	movw	r26, r24
    1ff2:	cb 01       	movw	r24, r22
    1ff4:	8f 83       	std	Y+7, r24	; 0x07
    1ff6:	98 87       	std	Y+8, r25	; 0x08
    1ff8:	a9 87       	std	Y+9, r26	; 0x09
    1ffa:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1ffc:	6f 81       	ldd	r22, Y+7	; 0x07
    1ffe:	78 85       	ldd	r23, Y+8	; 0x08
    2000:	89 85       	ldd	r24, Y+9	; 0x09
    2002:	9a 85       	ldd	r25, Y+10	; 0x0a
    2004:	20 e0       	ldi	r18, 0x00	; 0
    2006:	30 e0       	ldi	r19, 0x00	; 0
    2008:	40 e8       	ldi	r20, 0x80	; 128
    200a:	5f e3       	ldi	r21, 0x3F	; 63
    200c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2010:	88 23       	and	r24, r24
    2012:	2c f4       	brge	.+10     	; 0x201e <receive2pass_UART+0xc8>
		__ticks = 1;
    2014:	81 e0       	ldi	r24, 0x01	; 1
    2016:	90 e0       	ldi	r25, 0x00	; 0
    2018:	9e 83       	std	Y+6, r25	; 0x06
    201a:	8d 83       	std	Y+5, r24	; 0x05
    201c:	3f c0       	rjmp	.+126    	; 0x209c <receive2pass_UART+0x146>
	else if (__tmp > 65535)
    201e:	6f 81       	ldd	r22, Y+7	; 0x07
    2020:	78 85       	ldd	r23, Y+8	; 0x08
    2022:	89 85       	ldd	r24, Y+9	; 0x09
    2024:	9a 85       	ldd	r25, Y+10	; 0x0a
    2026:	20 e0       	ldi	r18, 0x00	; 0
    2028:	3f ef       	ldi	r19, 0xFF	; 255
    202a:	4f e7       	ldi	r20, 0x7F	; 127
    202c:	57 e4       	ldi	r21, 0x47	; 71
    202e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2032:	18 16       	cp	r1, r24
    2034:	4c f5       	brge	.+82     	; 0x2088 <receive2pass_UART+0x132>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2036:	6b 85       	ldd	r22, Y+11	; 0x0b
    2038:	7c 85       	ldd	r23, Y+12	; 0x0c
    203a:	8d 85       	ldd	r24, Y+13	; 0x0d
    203c:	9e 85       	ldd	r25, Y+14	; 0x0e
    203e:	20 e0       	ldi	r18, 0x00	; 0
    2040:	30 e0       	ldi	r19, 0x00	; 0
    2042:	40 e2       	ldi	r20, 0x20	; 32
    2044:	51 e4       	ldi	r21, 0x41	; 65
    2046:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    204a:	dc 01       	movw	r26, r24
    204c:	cb 01       	movw	r24, r22
    204e:	bc 01       	movw	r22, r24
    2050:	cd 01       	movw	r24, r26
    2052:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2056:	dc 01       	movw	r26, r24
    2058:	cb 01       	movw	r24, r22
    205a:	9e 83       	std	Y+6, r25	; 0x06
    205c:	8d 83       	std	Y+5, r24	; 0x05
    205e:	0f c0       	rjmp	.+30     	; 0x207e <receive2pass_UART+0x128>
    2060:	88 ec       	ldi	r24, 0xC8	; 200
    2062:	90 e0       	ldi	r25, 0x00	; 0
    2064:	9c 83       	std	Y+4, r25	; 0x04
    2066:	8b 83       	std	Y+3, r24	; 0x03
    2068:	8b 81       	ldd	r24, Y+3	; 0x03
    206a:	9c 81       	ldd	r25, Y+4	; 0x04
    206c:	01 97       	sbiw	r24, 0x01	; 1
    206e:	f1 f7       	brne	.-4      	; 0x206c <receive2pass_UART+0x116>
    2070:	9c 83       	std	Y+4, r25	; 0x04
    2072:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2074:	8d 81       	ldd	r24, Y+5	; 0x05
    2076:	9e 81       	ldd	r25, Y+6	; 0x06
    2078:	01 97       	sbiw	r24, 0x01	; 1
    207a:	9e 83       	std	Y+6, r25	; 0x06
    207c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    207e:	8d 81       	ldd	r24, Y+5	; 0x05
    2080:	9e 81       	ldd	r25, Y+6	; 0x06
    2082:	00 97       	sbiw	r24, 0x00	; 0
    2084:	69 f7       	brne	.-38     	; 0x2060 <receive2pass_UART+0x10a>
    2086:	14 c0       	rjmp	.+40     	; 0x20b0 <receive2pass_UART+0x15a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2088:	6f 81       	ldd	r22, Y+7	; 0x07
    208a:	78 85       	ldd	r23, Y+8	; 0x08
    208c:	89 85       	ldd	r24, Y+9	; 0x09
    208e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2090:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2094:	dc 01       	movw	r26, r24
    2096:	cb 01       	movw	r24, r22
    2098:	9e 83       	std	Y+6, r25	; 0x06
    209a:	8d 83       	std	Y+5, r24	; 0x05
    209c:	8d 81       	ldd	r24, Y+5	; 0x05
    209e:	9e 81       	ldd	r25, Y+6	; 0x06
    20a0:	9a 83       	std	Y+2, r25	; 0x02
    20a2:	89 83       	std	Y+1, r24	; 0x01
    20a4:	89 81       	ldd	r24, Y+1	; 0x01
    20a6:	9a 81       	ldd	r25, Y+2	; 0x02
    20a8:	01 97       	sbiw	r24, 0x01	; 1
    20aa:	f1 f7       	brne	.-4      	; 0x20a8 <receive2pass_UART+0x152>
    20ac:	9a 83       	std	Y+2, r25	; 0x02
    20ae:	89 83       	std	Y+1, r24	; 0x01
	{
		 userPass2[counter] =UART_recieveByte();
	}
	_delay_ms(500 );
}
    20b0:	63 96       	adiw	r28, 0x13	; 19
    20b2:	0f b6       	in	r0, 0x3f	; 63
    20b4:	f8 94       	cli
    20b6:	de bf       	out	0x3e, r29	; 62
    20b8:	0f be       	out	0x3f, r0	; 63
    20ba:	cd bf       	out	0x3d, r28	; 61
    20bc:	cf 91       	pop	r28
    20be:	df 91       	pop	r29
    20c0:	1f 91       	pop	r17
    20c2:	0f 91       	pop	r16
    20c4:	08 95       	ret

000020c6 <Compare_PASS>:

uint8 Compare_PASS(uint8 *userPass1, uint8 *userPass2,uint8 *savedPass)
{
    20c6:	df 93       	push	r29
    20c8:	cf 93       	push	r28
    20ca:	cd b7       	in	r28, 0x3d	; 61
    20cc:	de b7       	in	r29, 0x3e	; 62
    20ce:	28 97       	sbiw	r28, 0x08	; 8
    20d0:	0f b6       	in	r0, 0x3f	; 63
    20d2:	f8 94       	cli
    20d4:	de bf       	out	0x3e, r29	; 62
    20d6:	0f be       	out	0x3f, r0	; 63
    20d8:	cd bf       	out	0x3d, r28	; 61
    20da:	9b 83       	std	Y+3, r25	; 0x03
    20dc:	8a 83       	std	Y+2, r24	; 0x02
    20de:	7d 83       	std	Y+5, r23	; 0x05
    20e0:	6c 83       	std	Y+4, r22	; 0x04
    20e2:	5f 83       	std	Y+7, r21	; 0x07
    20e4:	4e 83       	std	Y+6, r20	; 0x06
	uint8 counter;
	for(counter =0;counter<PASS_LENGTH;counter++)
    20e6:	19 82       	std	Y+1, r1	; 0x01
    20e8:	2c c0       	rjmp	.+88     	; 0x2142 <Compare_PASS+0x7c>
	{
		if(userPass1[counter] != userPass2[counter])
    20ea:	89 81       	ldd	r24, Y+1	; 0x01
    20ec:	28 2f       	mov	r18, r24
    20ee:	30 e0       	ldi	r19, 0x00	; 0
    20f0:	8a 81       	ldd	r24, Y+2	; 0x02
    20f2:	9b 81       	ldd	r25, Y+3	; 0x03
    20f4:	fc 01       	movw	r30, r24
    20f6:	e2 0f       	add	r30, r18
    20f8:	f3 1f       	adc	r31, r19
    20fa:	40 81       	ld	r20, Z
    20fc:	89 81       	ldd	r24, Y+1	; 0x01
    20fe:	28 2f       	mov	r18, r24
    2100:	30 e0       	ldi	r19, 0x00	; 0
    2102:	8c 81       	ldd	r24, Y+4	; 0x04
    2104:	9d 81       	ldd	r25, Y+5	; 0x05
    2106:	fc 01       	movw	r30, r24
    2108:	e2 0f       	add	r30, r18
    210a:	f3 1f       	adc	r31, r19
    210c:	80 81       	ld	r24, Z
    210e:	48 17       	cp	r20, r24
    2110:	19 f0       	breq	.+6      	; 0x2118 <Compare_PASS+0x52>
		{
			  return INCORRECT_PASSWORD;
    2112:	81 e0       	ldi	r24, 0x01	; 1
    2114:	88 87       	std	Y+8, r24	; 0x08
    2116:	1a c0       	rjmp	.+52     	; 0x214c <Compare_PASS+0x86>
		}
		 savedPass[counter] = userPass1[counter];/*save the password*/
    2118:	89 81       	ldd	r24, Y+1	; 0x01
    211a:	28 2f       	mov	r18, r24
    211c:	30 e0       	ldi	r19, 0x00	; 0
    211e:	8e 81       	ldd	r24, Y+6	; 0x06
    2120:	9f 81       	ldd	r25, Y+7	; 0x07
    2122:	dc 01       	movw	r26, r24
    2124:	a2 0f       	add	r26, r18
    2126:	b3 1f       	adc	r27, r19
    2128:	89 81       	ldd	r24, Y+1	; 0x01
    212a:	28 2f       	mov	r18, r24
    212c:	30 e0       	ldi	r19, 0x00	; 0
    212e:	8a 81       	ldd	r24, Y+2	; 0x02
    2130:	9b 81       	ldd	r25, Y+3	; 0x03
    2132:	fc 01       	movw	r30, r24
    2134:	e2 0f       	add	r30, r18
    2136:	f3 1f       	adc	r31, r19
    2138:	80 81       	ld	r24, Z
    213a:	8c 93       	st	X, r24
}

uint8 Compare_PASS(uint8 *userPass1, uint8 *userPass2,uint8 *savedPass)
{
	uint8 counter;
	for(counter =0;counter<PASS_LENGTH;counter++)
    213c:	89 81       	ldd	r24, Y+1	; 0x01
    213e:	8f 5f       	subi	r24, 0xFF	; 255
    2140:	89 83       	std	Y+1, r24	; 0x01
    2142:	89 81       	ldd	r24, Y+1	; 0x01
    2144:	85 30       	cpi	r24, 0x05	; 5
    2146:	88 f2       	brcs	.-94     	; 0x20ea <Compare_PASS+0x24>
		{
			  return INCORRECT_PASSWORD;
		}
		 savedPass[counter] = userPass1[counter];/*save the password*/
	}
	 return CORRECT_PASSWORD;
    2148:	82 e0       	ldi	r24, 0x02	; 2
    214a:	88 87       	std	Y+8, r24	; 0x08
    214c:	88 85       	ldd	r24, Y+8	; 0x08
}
    214e:	28 96       	adiw	r28, 0x08	; 8
    2150:	0f b6       	in	r0, 0x3f	; 63
    2152:	f8 94       	cli
    2154:	de bf       	out	0x3e, r29	; 62
    2156:	0f be       	out	0x3f, r0	; 63
    2158:	cd bf       	out	0x3d, r28	; 61
    215a:	cf 91       	pop	r28
    215c:	df 91       	pop	r29
    215e:	08 95       	ret

00002160 <EEPROM_write_Password>:

/*
 * EEPROM READ & WRITE functions
 */
void EEPROM_write_Password(uint8 *savedPass)
{
    2160:	df 93       	push	r29
    2162:	cf 93       	push	r28
    2164:	cd b7       	in	r28, 0x3d	; 61
    2166:	de b7       	in	r29, 0x3e	; 62
    2168:	61 97       	sbiw	r28, 0x11	; 17
    216a:	0f b6       	in	r0, 0x3f	; 63
    216c:	f8 94       	cli
    216e:	de bf       	out	0x3e, r29	; 62
    2170:	0f be       	out	0x3f, r0	; 63
    2172:	cd bf       	out	0x3d, r28	; 61
    2174:	99 8b       	std	Y+17, r25	; 0x11
    2176:	88 8b       	std	Y+16, r24	; 0x10
	uint8 counter;
	for (counter =0;counter<PASS_LENGTH;counter++)
    2178:	1f 86       	std	Y+15, r1	; 0x0f
    217a:	87 c0       	rjmp	.+270    	; 0x228a <EEPROM_write_Password+0x12a>
	{
		  EEPROM_writeByte(0x01 + counter,savedPass[counter]);
    217c:	8f 85       	ldd	r24, Y+15	; 0x0f
    217e:	88 2f       	mov	r24, r24
    2180:	90 e0       	ldi	r25, 0x00	; 0
    2182:	01 96       	adiw	r24, 0x01	; 1
    2184:	ac 01       	movw	r20, r24
    2186:	8f 85       	ldd	r24, Y+15	; 0x0f
    2188:	28 2f       	mov	r18, r24
    218a:	30 e0       	ldi	r19, 0x00	; 0
    218c:	88 89       	ldd	r24, Y+16	; 0x10
    218e:	99 89       	ldd	r25, Y+17	; 0x11
    2190:	fc 01       	movw	r30, r24
    2192:	e2 0f       	add	r30, r18
    2194:	f3 1f       	adc	r31, r19
    2196:	20 81       	ld	r18, Z
    2198:	ca 01       	movw	r24, r20
    219a:	62 2f       	mov	r22, r18
    219c:	0e 94 77 0b 	call	0x16ee	; 0x16ee <EEPROM_writeByte>
    21a0:	80 e0       	ldi	r24, 0x00	; 0
    21a2:	90 e0       	ldi	r25, 0x00	; 0
    21a4:	a8 e4       	ldi	r26, 0x48	; 72
    21a6:	b3 e4       	ldi	r27, 0x43	; 67
    21a8:	8b 87       	std	Y+11, r24	; 0x0b
    21aa:	9c 87       	std	Y+12, r25	; 0x0c
    21ac:	ad 87       	std	Y+13, r26	; 0x0d
    21ae:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    21b0:	6b 85       	ldd	r22, Y+11	; 0x0b
    21b2:	7c 85       	ldd	r23, Y+12	; 0x0c
    21b4:	8d 85       	ldd	r24, Y+13	; 0x0d
    21b6:	9e 85       	ldd	r25, Y+14	; 0x0e
    21b8:	20 e0       	ldi	r18, 0x00	; 0
    21ba:	30 e0       	ldi	r19, 0x00	; 0
    21bc:	4a ef       	ldi	r20, 0xFA	; 250
    21be:	54 e4       	ldi	r21, 0x44	; 68
    21c0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    21c4:	dc 01       	movw	r26, r24
    21c6:	cb 01       	movw	r24, r22
    21c8:	8f 83       	std	Y+7, r24	; 0x07
    21ca:	98 87       	std	Y+8, r25	; 0x08
    21cc:	a9 87       	std	Y+9, r26	; 0x09
    21ce:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    21d0:	6f 81       	ldd	r22, Y+7	; 0x07
    21d2:	78 85       	ldd	r23, Y+8	; 0x08
    21d4:	89 85       	ldd	r24, Y+9	; 0x09
    21d6:	9a 85       	ldd	r25, Y+10	; 0x0a
    21d8:	20 e0       	ldi	r18, 0x00	; 0
    21da:	30 e0       	ldi	r19, 0x00	; 0
    21dc:	40 e8       	ldi	r20, 0x80	; 128
    21de:	5f e3       	ldi	r21, 0x3F	; 63
    21e0:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    21e4:	88 23       	and	r24, r24
    21e6:	2c f4       	brge	.+10     	; 0x21f2 <EEPROM_write_Password+0x92>
		__ticks = 1;
    21e8:	81 e0       	ldi	r24, 0x01	; 1
    21ea:	90 e0       	ldi	r25, 0x00	; 0
    21ec:	9e 83       	std	Y+6, r25	; 0x06
    21ee:	8d 83       	std	Y+5, r24	; 0x05
    21f0:	3f c0       	rjmp	.+126    	; 0x2270 <EEPROM_write_Password+0x110>
	else if (__tmp > 65535)
    21f2:	6f 81       	ldd	r22, Y+7	; 0x07
    21f4:	78 85       	ldd	r23, Y+8	; 0x08
    21f6:	89 85       	ldd	r24, Y+9	; 0x09
    21f8:	9a 85       	ldd	r25, Y+10	; 0x0a
    21fa:	20 e0       	ldi	r18, 0x00	; 0
    21fc:	3f ef       	ldi	r19, 0xFF	; 255
    21fe:	4f e7       	ldi	r20, 0x7F	; 127
    2200:	57 e4       	ldi	r21, 0x47	; 71
    2202:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2206:	18 16       	cp	r1, r24
    2208:	4c f5       	brge	.+82     	; 0x225c <EEPROM_write_Password+0xfc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    220a:	6b 85       	ldd	r22, Y+11	; 0x0b
    220c:	7c 85       	ldd	r23, Y+12	; 0x0c
    220e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2210:	9e 85       	ldd	r25, Y+14	; 0x0e
    2212:	20 e0       	ldi	r18, 0x00	; 0
    2214:	30 e0       	ldi	r19, 0x00	; 0
    2216:	40 e2       	ldi	r20, 0x20	; 32
    2218:	51 e4       	ldi	r21, 0x41	; 65
    221a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    221e:	dc 01       	movw	r26, r24
    2220:	cb 01       	movw	r24, r22
    2222:	bc 01       	movw	r22, r24
    2224:	cd 01       	movw	r24, r26
    2226:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    222a:	dc 01       	movw	r26, r24
    222c:	cb 01       	movw	r24, r22
    222e:	9e 83       	std	Y+6, r25	; 0x06
    2230:	8d 83       	std	Y+5, r24	; 0x05
    2232:	0f c0       	rjmp	.+30     	; 0x2252 <EEPROM_write_Password+0xf2>
    2234:	88 ec       	ldi	r24, 0xC8	; 200
    2236:	90 e0       	ldi	r25, 0x00	; 0
    2238:	9c 83       	std	Y+4, r25	; 0x04
    223a:	8b 83       	std	Y+3, r24	; 0x03
    223c:	8b 81       	ldd	r24, Y+3	; 0x03
    223e:	9c 81       	ldd	r25, Y+4	; 0x04
    2240:	01 97       	sbiw	r24, 0x01	; 1
    2242:	f1 f7       	brne	.-4      	; 0x2240 <EEPROM_write_Password+0xe0>
    2244:	9c 83       	std	Y+4, r25	; 0x04
    2246:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2248:	8d 81       	ldd	r24, Y+5	; 0x05
    224a:	9e 81       	ldd	r25, Y+6	; 0x06
    224c:	01 97       	sbiw	r24, 0x01	; 1
    224e:	9e 83       	std	Y+6, r25	; 0x06
    2250:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2252:	8d 81       	ldd	r24, Y+5	; 0x05
    2254:	9e 81       	ldd	r25, Y+6	; 0x06
    2256:	00 97       	sbiw	r24, 0x00	; 0
    2258:	69 f7       	brne	.-38     	; 0x2234 <EEPROM_write_Password+0xd4>
    225a:	14 c0       	rjmp	.+40     	; 0x2284 <EEPROM_write_Password+0x124>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    225c:	6f 81       	ldd	r22, Y+7	; 0x07
    225e:	78 85       	ldd	r23, Y+8	; 0x08
    2260:	89 85       	ldd	r24, Y+9	; 0x09
    2262:	9a 85       	ldd	r25, Y+10	; 0x0a
    2264:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2268:	dc 01       	movw	r26, r24
    226a:	cb 01       	movw	r24, r22
    226c:	9e 83       	std	Y+6, r25	; 0x06
    226e:	8d 83       	std	Y+5, r24	; 0x05
    2270:	8d 81       	ldd	r24, Y+5	; 0x05
    2272:	9e 81       	ldd	r25, Y+6	; 0x06
    2274:	9a 83       	std	Y+2, r25	; 0x02
    2276:	89 83       	std	Y+1, r24	; 0x01
    2278:	89 81       	ldd	r24, Y+1	; 0x01
    227a:	9a 81       	ldd	r25, Y+2	; 0x02
    227c:	01 97       	sbiw	r24, 0x01	; 1
    227e:	f1 f7       	brne	.-4      	; 0x227c <EEPROM_write_Password+0x11c>
    2280:	9a 83       	std	Y+2, r25	; 0x02
    2282:	89 83       	std	Y+1, r24	; 0x01
 * EEPROM READ & WRITE functions
 */
void EEPROM_write_Password(uint8 *savedPass)
{
	uint8 counter;
	for (counter =0;counter<PASS_LENGTH;counter++)
    2284:	8f 85       	ldd	r24, Y+15	; 0x0f
    2286:	8f 5f       	subi	r24, 0xFF	; 255
    2288:	8f 87       	std	Y+15, r24	; 0x0f
    228a:	8f 85       	ldd	r24, Y+15	; 0x0f
    228c:	85 30       	cpi	r24, 0x05	; 5
    228e:	08 f4       	brcc	.+2      	; 0x2292 <EEPROM_write_Password+0x132>
    2290:	75 cf       	rjmp	.-278    	; 0x217c <EEPROM_write_Password+0x1c>
	{
		  EEPROM_writeByte(0x01 + counter,savedPass[counter]);
		  _delay_ms(200);
	}
}
    2292:	61 96       	adiw	r28, 0x11	; 17
    2294:	0f b6       	in	r0, 0x3f	; 63
    2296:	f8 94       	cli
    2298:	de bf       	out	0x3e, r29	; 62
    229a:	0f be       	out	0x3f, r0	; 63
    229c:	cd bf       	out	0x3d, r28	; 61
    229e:	cf 91       	pop	r28
    22a0:	df 91       	pop	r29
    22a2:	08 95       	ret

000022a4 <EEPROM_read_Password>:
void EEPROM_read_Password(uint8 *savedPass)
{
    22a4:	df 93       	push	r29
    22a6:	cf 93       	push	r28
    22a8:	cd b7       	in	r28, 0x3d	; 61
    22aa:	de b7       	in	r29, 0x3e	; 62
    22ac:	62 97       	sbiw	r28, 0x12	; 18
    22ae:	0f b6       	in	r0, 0x3f	; 63
    22b0:	f8 94       	cli
    22b2:	de bf       	out	0x3e, r29	; 62
    22b4:	0f be       	out	0x3f, r0	; 63
    22b6:	cd bf       	out	0x3d, r28	; 61
    22b8:	9a 8b       	std	Y+18, r25	; 0x12
    22ba:	89 8b       	std	Y+17, r24	; 0x11
	uint8 EEPROM_Read_Byte;
	uint8 counter;
	for (counter =0;counter<PASS_LENGTH ;counter++)
    22bc:	1f 86       	std	Y+15, r1	; 0x0f
    22be:	89 c0       	rjmp	.+274    	; 0x23d2 <EEPROM_read_Password+0x12e>
	{
		 EEPROM_readByte(0x01 + counter,&EEPROM_Read_Byte);
    22c0:	8f 85       	ldd	r24, Y+15	; 0x0f
    22c2:	88 2f       	mov	r24, r24
    22c4:	90 e0       	ldi	r25, 0x00	; 0
    22c6:	01 96       	adiw	r24, 0x01	; 1
    22c8:	9e 01       	movw	r18, r28
    22ca:	20 5f       	subi	r18, 0xF0	; 240
    22cc:	3f 4f       	sbci	r19, 0xFF	; 255
    22ce:	b9 01       	movw	r22, r18
    22d0:	0e 94 b8 0b 	call	0x1770	; 0x1770 <EEPROM_readByte>
		 savedPass[counter] = EEPROM_Read_Byte;
    22d4:	8f 85       	ldd	r24, Y+15	; 0x0f
    22d6:	28 2f       	mov	r18, r24
    22d8:	30 e0       	ldi	r19, 0x00	; 0
    22da:	89 89       	ldd	r24, Y+17	; 0x11
    22dc:	9a 89       	ldd	r25, Y+18	; 0x12
    22de:	fc 01       	movw	r30, r24
    22e0:	e2 0f       	add	r30, r18
    22e2:	f3 1f       	adc	r31, r19
    22e4:	88 89       	ldd	r24, Y+16	; 0x10
    22e6:	80 83       	st	Z, r24
    22e8:	80 e0       	ldi	r24, 0x00	; 0
    22ea:	90 e0       	ldi	r25, 0x00	; 0
    22ec:	a8 e4       	ldi	r26, 0x48	; 72
    22ee:	b3 e4       	ldi	r27, 0x43	; 67
    22f0:	8b 87       	std	Y+11, r24	; 0x0b
    22f2:	9c 87       	std	Y+12, r25	; 0x0c
    22f4:	ad 87       	std	Y+13, r26	; 0x0d
    22f6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    22f8:	6b 85       	ldd	r22, Y+11	; 0x0b
    22fa:	7c 85       	ldd	r23, Y+12	; 0x0c
    22fc:	8d 85       	ldd	r24, Y+13	; 0x0d
    22fe:	9e 85       	ldd	r25, Y+14	; 0x0e
    2300:	20 e0       	ldi	r18, 0x00	; 0
    2302:	30 e0       	ldi	r19, 0x00	; 0
    2304:	4a ef       	ldi	r20, 0xFA	; 250
    2306:	54 e4       	ldi	r21, 0x44	; 68
    2308:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    230c:	dc 01       	movw	r26, r24
    230e:	cb 01       	movw	r24, r22
    2310:	8f 83       	std	Y+7, r24	; 0x07
    2312:	98 87       	std	Y+8, r25	; 0x08
    2314:	a9 87       	std	Y+9, r26	; 0x09
    2316:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2318:	6f 81       	ldd	r22, Y+7	; 0x07
    231a:	78 85       	ldd	r23, Y+8	; 0x08
    231c:	89 85       	ldd	r24, Y+9	; 0x09
    231e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2320:	20 e0       	ldi	r18, 0x00	; 0
    2322:	30 e0       	ldi	r19, 0x00	; 0
    2324:	40 e8       	ldi	r20, 0x80	; 128
    2326:	5f e3       	ldi	r21, 0x3F	; 63
    2328:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    232c:	88 23       	and	r24, r24
    232e:	2c f4       	brge	.+10     	; 0x233a <EEPROM_read_Password+0x96>
		__ticks = 1;
    2330:	81 e0       	ldi	r24, 0x01	; 1
    2332:	90 e0       	ldi	r25, 0x00	; 0
    2334:	9e 83       	std	Y+6, r25	; 0x06
    2336:	8d 83       	std	Y+5, r24	; 0x05
    2338:	3f c0       	rjmp	.+126    	; 0x23b8 <EEPROM_read_Password+0x114>
	else if (__tmp > 65535)
    233a:	6f 81       	ldd	r22, Y+7	; 0x07
    233c:	78 85       	ldd	r23, Y+8	; 0x08
    233e:	89 85       	ldd	r24, Y+9	; 0x09
    2340:	9a 85       	ldd	r25, Y+10	; 0x0a
    2342:	20 e0       	ldi	r18, 0x00	; 0
    2344:	3f ef       	ldi	r19, 0xFF	; 255
    2346:	4f e7       	ldi	r20, 0x7F	; 127
    2348:	57 e4       	ldi	r21, 0x47	; 71
    234a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    234e:	18 16       	cp	r1, r24
    2350:	4c f5       	brge	.+82     	; 0x23a4 <EEPROM_read_Password+0x100>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2352:	6b 85       	ldd	r22, Y+11	; 0x0b
    2354:	7c 85       	ldd	r23, Y+12	; 0x0c
    2356:	8d 85       	ldd	r24, Y+13	; 0x0d
    2358:	9e 85       	ldd	r25, Y+14	; 0x0e
    235a:	20 e0       	ldi	r18, 0x00	; 0
    235c:	30 e0       	ldi	r19, 0x00	; 0
    235e:	40 e2       	ldi	r20, 0x20	; 32
    2360:	51 e4       	ldi	r21, 0x41	; 65
    2362:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2366:	dc 01       	movw	r26, r24
    2368:	cb 01       	movw	r24, r22
    236a:	bc 01       	movw	r22, r24
    236c:	cd 01       	movw	r24, r26
    236e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2372:	dc 01       	movw	r26, r24
    2374:	cb 01       	movw	r24, r22
    2376:	9e 83       	std	Y+6, r25	; 0x06
    2378:	8d 83       	std	Y+5, r24	; 0x05
    237a:	0f c0       	rjmp	.+30     	; 0x239a <EEPROM_read_Password+0xf6>
    237c:	88 ec       	ldi	r24, 0xC8	; 200
    237e:	90 e0       	ldi	r25, 0x00	; 0
    2380:	9c 83       	std	Y+4, r25	; 0x04
    2382:	8b 83       	std	Y+3, r24	; 0x03
    2384:	8b 81       	ldd	r24, Y+3	; 0x03
    2386:	9c 81       	ldd	r25, Y+4	; 0x04
    2388:	01 97       	sbiw	r24, 0x01	; 1
    238a:	f1 f7       	brne	.-4      	; 0x2388 <EEPROM_read_Password+0xe4>
    238c:	9c 83       	std	Y+4, r25	; 0x04
    238e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2390:	8d 81       	ldd	r24, Y+5	; 0x05
    2392:	9e 81       	ldd	r25, Y+6	; 0x06
    2394:	01 97       	sbiw	r24, 0x01	; 1
    2396:	9e 83       	std	Y+6, r25	; 0x06
    2398:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    239a:	8d 81       	ldd	r24, Y+5	; 0x05
    239c:	9e 81       	ldd	r25, Y+6	; 0x06
    239e:	00 97       	sbiw	r24, 0x00	; 0
    23a0:	69 f7       	brne	.-38     	; 0x237c <EEPROM_read_Password+0xd8>
    23a2:	14 c0       	rjmp	.+40     	; 0x23cc <EEPROM_read_Password+0x128>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    23a4:	6f 81       	ldd	r22, Y+7	; 0x07
    23a6:	78 85       	ldd	r23, Y+8	; 0x08
    23a8:	89 85       	ldd	r24, Y+9	; 0x09
    23aa:	9a 85       	ldd	r25, Y+10	; 0x0a
    23ac:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    23b0:	dc 01       	movw	r26, r24
    23b2:	cb 01       	movw	r24, r22
    23b4:	9e 83       	std	Y+6, r25	; 0x06
    23b6:	8d 83       	std	Y+5, r24	; 0x05
    23b8:	8d 81       	ldd	r24, Y+5	; 0x05
    23ba:	9e 81       	ldd	r25, Y+6	; 0x06
    23bc:	9a 83       	std	Y+2, r25	; 0x02
    23be:	89 83       	std	Y+1, r24	; 0x01
    23c0:	89 81       	ldd	r24, Y+1	; 0x01
    23c2:	9a 81       	ldd	r25, Y+2	; 0x02
    23c4:	01 97       	sbiw	r24, 0x01	; 1
    23c6:	f1 f7       	brne	.-4      	; 0x23c4 <EEPROM_read_Password+0x120>
    23c8:	9a 83       	std	Y+2, r25	; 0x02
    23ca:	89 83       	std	Y+1, r24	; 0x01
}
void EEPROM_read_Password(uint8 *savedPass)
{
	uint8 EEPROM_Read_Byte;
	uint8 counter;
	for (counter =0;counter<PASS_LENGTH ;counter++)
    23cc:	8f 85       	ldd	r24, Y+15	; 0x0f
    23ce:	8f 5f       	subi	r24, 0xFF	; 255
    23d0:	8f 87       	std	Y+15, r24	; 0x0f
    23d2:	8f 85       	ldd	r24, Y+15	; 0x0f
    23d4:	85 30       	cpi	r24, 0x05	; 5
    23d6:	08 f4       	brcc	.+2      	; 0x23da <EEPROM_read_Password+0x136>
    23d8:	73 cf       	rjmp	.-282    	; 0x22c0 <EEPROM_read_Password+0x1c>
	{
		 EEPROM_readByte(0x01 + counter,&EEPROM_Read_Byte);
		 savedPass[counter] = EEPROM_Read_Byte;
		 _delay_ms(200);
	}
}
    23da:	62 96       	adiw	r28, 0x12	; 18
    23dc:	0f b6       	in	r0, 0x3f	; 63
    23de:	f8 94       	cli
    23e0:	de bf       	out	0x3e, r29	; 62
    23e2:	0f be       	out	0x3f, r0	; 63
    23e4:	cd bf       	out	0x3d, r28	; 61
    23e6:	cf 91       	pop	r28
    23e8:	df 91       	pop	r29
    23ea:	08 95       	ret

000023ec <storePass>:
/*
 * store pass in eeprom & send state of password
 */
void storePass(uint8 *savedPass)
{
    23ec:	df 93       	push	r29
    23ee:	cf 93       	push	r28
    23f0:	cd b7       	in	r28, 0x3d	; 61
    23f2:	de b7       	in	r29, 0x3e	; 62
    23f4:	6e 97       	sbiw	r28, 0x1e	; 30
    23f6:	0f b6       	in	r0, 0x3f	; 63
    23f8:	f8 94       	cli
    23fa:	de bf       	out	0x3e, r29	; 62
    23fc:	0f be       	out	0x3f, r0	; 63
    23fe:	cd bf       	out	0x3d, r28	; 61
    2400:	9e 8f       	std	Y+30, r25	; 0x1e
    2402:	8d 8f       	std	Y+29, r24	; 0x1d
	EEPROM_write_Password(savedPass);
    2404:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2406:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2408:	0e 94 b0 10 	call	0x2160	; 0x2160 <EEPROM_write_Password>
	EEPROM_read_Password(savedPass);
    240c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    240e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2410:	0e 94 52 11 	call	0x22a4	; 0x22a4 <EEPROM_read_Password>
    2414:	80 e0       	ldi	r24, 0x00	; 0
    2416:	90 e0       	ldi	r25, 0x00	; 0
    2418:	aa ef       	ldi	r26, 0xFA	; 250
    241a:	b3 e4       	ldi	r27, 0x43	; 67
    241c:	89 8f       	std	Y+25, r24	; 0x19
    241e:	9a 8f       	std	Y+26, r25	; 0x1a
    2420:	ab 8f       	std	Y+27, r26	; 0x1b
    2422:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2424:	69 8d       	ldd	r22, Y+25	; 0x19
    2426:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2428:	8b 8d       	ldd	r24, Y+27	; 0x1b
    242a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    242c:	20 e0       	ldi	r18, 0x00	; 0
    242e:	30 e0       	ldi	r19, 0x00	; 0
    2430:	4a ef       	ldi	r20, 0xFA	; 250
    2432:	54 e4       	ldi	r21, 0x44	; 68
    2434:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2438:	dc 01       	movw	r26, r24
    243a:	cb 01       	movw	r24, r22
    243c:	8d 8b       	std	Y+21, r24	; 0x15
    243e:	9e 8b       	std	Y+22, r25	; 0x16
    2440:	af 8b       	std	Y+23, r26	; 0x17
    2442:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    2444:	6d 89       	ldd	r22, Y+21	; 0x15
    2446:	7e 89       	ldd	r23, Y+22	; 0x16
    2448:	8f 89       	ldd	r24, Y+23	; 0x17
    244a:	98 8d       	ldd	r25, Y+24	; 0x18
    244c:	20 e0       	ldi	r18, 0x00	; 0
    244e:	30 e0       	ldi	r19, 0x00	; 0
    2450:	40 e8       	ldi	r20, 0x80	; 128
    2452:	5f e3       	ldi	r21, 0x3F	; 63
    2454:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2458:	88 23       	and	r24, r24
    245a:	2c f4       	brge	.+10     	; 0x2466 <storePass+0x7a>
		__ticks = 1;
    245c:	81 e0       	ldi	r24, 0x01	; 1
    245e:	90 e0       	ldi	r25, 0x00	; 0
    2460:	9c 8b       	std	Y+20, r25	; 0x14
    2462:	8b 8b       	std	Y+19, r24	; 0x13
    2464:	3f c0       	rjmp	.+126    	; 0x24e4 <storePass+0xf8>
	else if (__tmp > 65535)
    2466:	6d 89       	ldd	r22, Y+21	; 0x15
    2468:	7e 89       	ldd	r23, Y+22	; 0x16
    246a:	8f 89       	ldd	r24, Y+23	; 0x17
    246c:	98 8d       	ldd	r25, Y+24	; 0x18
    246e:	20 e0       	ldi	r18, 0x00	; 0
    2470:	3f ef       	ldi	r19, 0xFF	; 255
    2472:	4f e7       	ldi	r20, 0x7F	; 127
    2474:	57 e4       	ldi	r21, 0x47	; 71
    2476:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    247a:	18 16       	cp	r1, r24
    247c:	4c f5       	brge	.+82     	; 0x24d0 <storePass+0xe4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    247e:	69 8d       	ldd	r22, Y+25	; 0x19
    2480:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2482:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2484:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2486:	20 e0       	ldi	r18, 0x00	; 0
    2488:	30 e0       	ldi	r19, 0x00	; 0
    248a:	40 e2       	ldi	r20, 0x20	; 32
    248c:	51 e4       	ldi	r21, 0x41	; 65
    248e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2492:	dc 01       	movw	r26, r24
    2494:	cb 01       	movw	r24, r22
    2496:	bc 01       	movw	r22, r24
    2498:	cd 01       	movw	r24, r26
    249a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    249e:	dc 01       	movw	r26, r24
    24a0:	cb 01       	movw	r24, r22
    24a2:	9c 8b       	std	Y+20, r25	; 0x14
    24a4:	8b 8b       	std	Y+19, r24	; 0x13
    24a6:	0f c0       	rjmp	.+30     	; 0x24c6 <storePass+0xda>
    24a8:	88 ec       	ldi	r24, 0xC8	; 200
    24aa:	90 e0       	ldi	r25, 0x00	; 0
    24ac:	9a 8b       	std	Y+18, r25	; 0x12
    24ae:	89 8b       	std	Y+17, r24	; 0x11
    24b0:	89 89       	ldd	r24, Y+17	; 0x11
    24b2:	9a 89       	ldd	r25, Y+18	; 0x12
    24b4:	01 97       	sbiw	r24, 0x01	; 1
    24b6:	f1 f7       	brne	.-4      	; 0x24b4 <storePass+0xc8>
    24b8:	9a 8b       	std	Y+18, r25	; 0x12
    24ba:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    24bc:	8b 89       	ldd	r24, Y+19	; 0x13
    24be:	9c 89       	ldd	r25, Y+20	; 0x14
    24c0:	01 97       	sbiw	r24, 0x01	; 1
    24c2:	9c 8b       	std	Y+20, r25	; 0x14
    24c4:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    24c6:	8b 89       	ldd	r24, Y+19	; 0x13
    24c8:	9c 89       	ldd	r25, Y+20	; 0x14
    24ca:	00 97       	sbiw	r24, 0x00	; 0
    24cc:	69 f7       	brne	.-38     	; 0x24a8 <storePass+0xbc>
    24ce:	14 c0       	rjmp	.+40     	; 0x24f8 <storePass+0x10c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    24d0:	6d 89       	ldd	r22, Y+21	; 0x15
    24d2:	7e 89       	ldd	r23, Y+22	; 0x16
    24d4:	8f 89       	ldd	r24, Y+23	; 0x17
    24d6:	98 8d       	ldd	r25, Y+24	; 0x18
    24d8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    24dc:	dc 01       	movw	r26, r24
    24de:	cb 01       	movw	r24, r22
    24e0:	9c 8b       	std	Y+20, r25	; 0x14
    24e2:	8b 8b       	std	Y+19, r24	; 0x13
    24e4:	8b 89       	ldd	r24, Y+19	; 0x13
    24e6:	9c 89       	ldd	r25, Y+20	; 0x14
    24e8:	98 8b       	std	Y+16, r25	; 0x10
    24ea:	8f 87       	std	Y+15, r24	; 0x0f
    24ec:	8f 85       	ldd	r24, Y+15	; 0x0f
    24ee:	98 89       	ldd	r25, Y+16	; 0x10
    24f0:	01 97       	sbiw	r24, 0x01	; 1
    24f2:	f1 f7       	brne	.-4      	; 0x24f0 <storePass+0x104>
    24f4:	98 8b       	std	Y+16, r25	; 0x10
    24f6:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(500);
	while (UART_recieveByte() != CHECKING_PASSWORD);
    24f8:	0e 94 08 07 	call	0xe10	; 0xe10 <UART_recieveByte>
    24fc:	84 30       	cpi	r24, 0x04	; 4
    24fe:	e1 f7       	brne	.-8      	; 0x24f8 <storePass+0x10c>
	UART_sendByte(CORRECT_PASSWORD);
    2500:	82 e0       	ldi	r24, 0x02	; 2
    2502:	0e 94 f1 06 	call	0xde2	; 0xde2 <UART_sendByte>
    2506:	80 e0       	ldi	r24, 0x00	; 0
    2508:	90 e0       	ldi	r25, 0x00	; 0
    250a:	aa ef       	ldi	r26, 0xFA	; 250
    250c:	b3 e4       	ldi	r27, 0x43	; 67
    250e:	8b 87       	std	Y+11, r24	; 0x0b
    2510:	9c 87       	std	Y+12, r25	; 0x0c
    2512:	ad 87       	std	Y+13, r26	; 0x0d
    2514:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2516:	6b 85       	ldd	r22, Y+11	; 0x0b
    2518:	7c 85       	ldd	r23, Y+12	; 0x0c
    251a:	8d 85       	ldd	r24, Y+13	; 0x0d
    251c:	9e 85       	ldd	r25, Y+14	; 0x0e
    251e:	20 e0       	ldi	r18, 0x00	; 0
    2520:	30 e0       	ldi	r19, 0x00	; 0
    2522:	4a ef       	ldi	r20, 0xFA	; 250
    2524:	54 e4       	ldi	r21, 0x44	; 68
    2526:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    252a:	dc 01       	movw	r26, r24
    252c:	cb 01       	movw	r24, r22
    252e:	8f 83       	std	Y+7, r24	; 0x07
    2530:	98 87       	std	Y+8, r25	; 0x08
    2532:	a9 87       	std	Y+9, r26	; 0x09
    2534:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2536:	6f 81       	ldd	r22, Y+7	; 0x07
    2538:	78 85       	ldd	r23, Y+8	; 0x08
    253a:	89 85       	ldd	r24, Y+9	; 0x09
    253c:	9a 85       	ldd	r25, Y+10	; 0x0a
    253e:	20 e0       	ldi	r18, 0x00	; 0
    2540:	30 e0       	ldi	r19, 0x00	; 0
    2542:	40 e8       	ldi	r20, 0x80	; 128
    2544:	5f e3       	ldi	r21, 0x3F	; 63
    2546:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    254a:	88 23       	and	r24, r24
    254c:	2c f4       	brge	.+10     	; 0x2558 <storePass+0x16c>
		__ticks = 1;
    254e:	81 e0       	ldi	r24, 0x01	; 1
    2550:	90 e0       	ldi	r25, 0x00	; 0
    2552:	9e 83       	std	Y+6, r25	; 0x06
    2554:	8d 83       	std	Y+5, r24	; 0x05
    2556:	3f c0       	rjmp	.+126    	; 0x25d6 <storePass+0x1ea>
	else if (__tmp > 65535)
    2558:	6f 81       	ldd	r22, Y+7	; 0x07
    255a:	78 85       	ldd	r23, Y+8	; 0x08
    255c:	89 85       	ldd	r24, Y+9	; 0x09
    255e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2560:	20 e0       	ldi	r18, 0x00	; 0
    2562:	3f ef       	ldi	r19, 0xFF	; 255
    2564:	4f e7       	ldi	r20, 0x7F	; 127
    2566:	57 e4       	ldi	r21, 0x47	; 71
    2568:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    256c:	18 16       	cp	r1, r24
    256e:	4c f5       	brge	.+82     	; 0x25c2 <storePass+0x1d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2570:	6b 85       	ldd	r22, Y+11	; 0x0b
    2572:	7c 85       	ldd	r23, Y+12	; 0x0c
    2574:	8d 85       	ldd	r24, Y+13	; 0x0d
    2576:	9e 85       	ldd	r25, Y+14	; 0x0e
    2578:	20 e0       	ldi	r18, 0x00	; 0
    257a:	30 e0       	ldi	r19, 0x00	; 0
    257c:	40 e2       	ldi	r20, 0x20	; 32
    257e:	51 e4       	ldi	r21, 0x41	; 65
    2580:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2584:	dc 01       	movw	r26, r24
    2586:	cb 01       	movw	r24, r22
    2588:	bc 01       	movw	r22, r24
    258a:	cd 01       	movw	r24, r26
    258c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2590:	dc 01       	movw	r26, r24
    2592:	cb 01       	movw	r24, r22
    2594:	9e 83       	std	Y+6, r25	; 0x06
    2596:	8d 83       	std	Y+5, r24	; 0x05
    2598:	0f c0       	rjmp	.+30     	; 0x25b8 <storePass+0x1cc>
    259a:	88 ec       	ldi	r24, 0xC8	; 200
    259c:	90 e0       	ldi	r25, 0x00	; 0
    259e:	9c 83       	std	Y+4, r25	; 0x04
    25a0:	8b 83       	std	Y+3, r24	; 0x03
    25a2:	8b 81       	ldd	r24, Y+3	; 0x03
    25a4:	9c 81       	ldd	r25, Y+4	; 0x04
    25a6:	01 97       	sbiw	r24, 0x01	; 1
    25a8:	f1 f7       	brne	.-4      	; 0x25a6 <storePass+0x1ba>
    25aa:	9c 83       	std	Y+4, r25	; 0x04
    25ac:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    25ae:	8d 81       	ldd	r24, Y+5	; 0x05
    25b0:	9e 81       	ldd	r25, Y+6	; 0x06
    25b2:	01 97       	sbiw	r24, 0x01	; 1
    25b4:	9e 83       	std	Y+6, r25	; 0x06
    25b6:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    25b8:	8d 81       	ldd	r24, Y+5	; 0x05
    25ba:	9e 81       	ldd	r25, Y+6	; 0x06
    25bc:	00 97       	sbiw	r24, 0x00	; 0
    25be:	69 f7       	brne	.-38     	; 0x259a <storePass+0x1ae>
    25c0:	14 c0       	rjmp	.+40     	; 0x25ea <storePass+0x1fe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    25c2:	6f 81       	ldd	r22, Y+7	; 0x07
    25c4:	78 85       	ldd	r23, Y+8	; 0x08
    25c6:	89 85       	ldd	r24, Y+9	; 0x09
    25c8:	9a 85       	ldd	r25, Y+10	; 0x0a
    25ca:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    25ce:	dc 01       	movw	r26, r24
    25d0:	cb 01       	movw	r24, r22
    25d2:	9e 83       	std	Y+6, r25	; 0x06
    25d4:	8d 83       	std	Y+5, r24	; 0x05
    25d6:	8d 81       	ldd	r24, Y+5	; 0x05
    25d8:	9e 81       	ldd	r25, Y+6	; 0x06
    25da:	9a 83       	std	Y+2, r25	; 0x02
    25dc:	89 83       	std	Y+1, r24	; 0x01
    25de:	89 81       	ldd	r24, Y+1	; 0x01
    25e0:	9a 81       	ldd	r25, Y+2	; 0x02
    25e2:	01 97       	sbiw	r24, 0x01	; 1
    25e4:	f1 f7       	brne	.-4      	; 0x25e2 <storePass+0x1f6>
    25e6:	9a 83       	std	Y+2, r25	; 0x02
    25e8:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(500);
	break_cond = 1;
    25ea:	81 e0       	ldi	r24, 0x01	; 1
    25ec:	80 93 69 00 	sts	0x0069, r24
}
    25f0:	6e 96       	adiw	r28, 0x1e	; 30
    25f2:	0f b6       	in	r0, 0x3f	; 63
    25f4:	f8 94       	cli
    25f6:	de bf       	out	0x3e, r29	; 62
    25f8:	0f be       	out	0x3f, r0	; 63
    25fa:	cd bf       	out	0x3d, r28	; 61
    25fc:	cf 91       	pop	r28
    25fe:	df 91       	pop	r29
    2600:	08 95       	ret

00002602 <Receive_PASS>:

/*
 * Receive Password And Compare with saved Password
 */
void Receive_PASS(uint8 *userPass)
{
    2602:	0f 93       	push	r16
    2604:	1f 93       	push	r17
    2606:	df 93       	push	r29
    2608:	cf 93       	push	r28
    260a:	cd b7       	in	r28, 0x3d	; 61
    260c:	de b7       	in	r29, 0x3e	; 62
    260e:	61 97       	sbiw	r28, 0x11	; 17
    2610:	0f b6       	in	r0, 0x3f	; 63
    2612:	f8 94       	cli
    2614:	de bf       	out	0x3e, r29	; 62
    2616:	0f be       	out	0x3f, r0	; 63
    2618:	cd bf       	out	0x3d, r28	; 61
    261a:	99 8b       	std	Y+17, r25	; 0x11
    261c:	88 8b       	std	Y+16, r24	; 0x10
	uint8 counter;
	UART_sendByte(AVALIABLE);
    261e:	85 e0       	ldi	r24, 0x05	; 5
    2620:	0e 94 f1 06 	call	0xde2	; 0xde2 <UART_sendByte>
	for (counter =0;counter<PASS_LENGTH;counter++)
    2624:	1f 86       	std	Y+15, r1	; 0x0f
    2626:	0f c0       	rjmp	.+30     	; 0x2646 <Receive_PASS+0x44>
	{
		 userPass[counter] = UART_recieveByte();
    2628:	8f 85       	ldd	r24, Y+15	; 0x0f
    262a:	28 2f       	mov	r18, r24
    262c:	30 e0       	ldi	r19, 0x00	; 0
    262e:	88 89       	ldd	r24, Y+16	; 0x10
    2630:	99 89       	ldd	r25, Y+17	; 0x11
    2632:	8c 01       	movw	r16, r24
    2634:	02 0f       	add	r16, r18
    2636:	13 1f       	adc	r17, r19
    2638:	0e 94 08 07 	call	0xe10	; 0xe10 <UART_recieveByte>
    263c:	f8 01       	movw	r30, r16
    263e:	80 83       	st	Z, r24
 */
void Receive_PASS(uint8 *userPass)
{
	uint8 counter;
	UART_sendByte(AVALIABLE);
	for (counter =0;counter<PASS_LENGTH;counter++)
    2640:	8f 85       	ldd	r24, Y+15	; 0x0f
    2642:	8f 5f       	subi	r24, 0xFF	; 255
    2644:	8f 87       	std	Y+15, r24	; 0x0f
    2646:	8f 85       	ldd	r24, Y+15	; 0x0f
    2648:	85 30       	cpi	r24, 0x05	; 5
    264a:	70 f3       	brcs	.-36     	; 0x2628 <Receive_PASS+0x26>
    264c:	80 e0       	ldi	r24, 0x00	; 0
    264e:	90 e0       	ldi	r25, 0x00	; 0
    2650:	aa ef       	ldi	r26, 0xFA	; 250
    2652:	b3 e4       	ldi	r27, 0x43	; 67
    2654:	8b 87       	std	Y+11, r24	; 0x0b
    2656:	9c 87       	std	Y+12, r25	; 0x0c
    2658:	ad 87       	std	Y+13, r26	; 0x0d
    265a:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    265c:	6b 85       	ldd	r22, Y+11	; 0x0b
    265e:	7c 85       	ldd	r23, Y+12	; 0x0c
    2660:	8d 85       	ldd	r24, Y+13	; 0x0d
    2662:	9e 85       	ldd	r25, Y+14	; 0x0e
    2664:	20 e0       	ldi	r18, 0x00	; 0
    2666:	30 e0       	ldi	r19, 0x00	; 0
    2668:	4a ef       	ldi	r20, 0xFA	; 250
    266a:	54 e4       	ldi	r21, 0x44	; 68
    266c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2670:	dc 01       	movw	r26, r24
    2672:	cb 01       	movw	r24, r22
    2674:	8f 83       	std	Y+7, r24	; 0x07
    2676:	98 87       	std	Y+8, r25	; 0x08
    2678:	a9 87       	std	Y+9, r26	; 0x09
    267a:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    267c:	6f 81       	ldd	r22, Y+7	; 0x07
    267e:	78 85       	ldd	r23, Y+8	; 0x08
    2680:	89 85       	ldd	r24, Y+9	; 0x09
    2682:	9a 85       	ldd	r25, Y+10	; 0x0a
    2684:	20 e0       	ldi	r18, 0x00	; 0
    2686:	30 e0       	ldi	r19, 0x00	; 0
    2688:	40 e8       	ldi	r20, 0x80	; 128
    268a:	5f e3       	ldi	r21, 0x3F	; 63
    268c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2690:	88 23       	and	r24, r24
    2692:	2c f4       	brge	.+10     	; 0x269e <Receive_PASS+0x9c>
		__ticks = 1;
    2694:	81 e0       	ldi	r24, 0x01	; 1
    2696:	90 e0       	ldi	r25, 0x00	; 0
    2698:	9e 83       	std	Y+6, r25	; 0x06
    269a:	8d 83       	std	Y+5, r24	; 0x05
    269c:	3f c0       	rjmp	.+126    	; 0x271c <Receive_PASS+0x11a>
	else if (__tmp > 65535)
    269e:	6f 81       	ldd	r22, Y+7	; 0x07
    26a0:	78 85       	ldd	r23, Y+8	; 0x08
    26a2:	89 85       	ldd	r24, Y+9	; 0x09
    26a4:	9a 85       	ldd	r25, Y+10	; 0x0a
    26a6:	20 e0       	ldi	r18, 0x00	; 0
    26a8:	3f ef       	ldi	r19, 0xFF	; 255
    26aa:	4f e7       	ldi	r20, 0x7F	; 127
    26ac:	57 e4       	ldi	r21, 0x47	; 71
    26ae:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    26b2:	18 16       	cp	r1, r24
    26b4:	4c f5       	brge	.+82     	; 0x2708 <Receive_PASS+0x106>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    26b6:	6b 85       	ldd	r22, Y+11	; 0x0b
    26b8:	7c 85       	ldd	r23, Y+12	; 0x0c
    26ba:	8d 85       	ldd	r24, Y+13	; 0x0d
    26bc:	9e 85       	ldd	r25, Y+14	; 0x0e
    26be:	20 e0       	ldi	r18, 0x00	; 0
    26c0:	30 e0       	ldi	r19, 0x00	; 0
    26c2:	40 e2       	ldi	r20, 0x20	; 32
    26c4:	51 e4       	ldi	r21, 0x41	; 65
    26c6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    26ca:	dc 01       	movw	r26, r24
    26cc:	cb 01       	movw	r24, r22
    26ce:	bc 01       	movw	r22, r24
    26d0:	cd 01       	movw	r24, r26
    26d2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    26d6:	dc 01       	movw	r26, r24
    26d8:	cb 01       	movw	r24, r22
    26da:	9e 83       	std	Y+6, r25	; 0x06
    26dc:	8d 83       	std	Y+5, r24	; 0x05
    26de:	0f c0       	rjmp	.+30     	; 0x26fe <Receive_PASS+0xfc>
    26e0:	88 ec       	ldi	r24, 0xC8	; 200
    26e2:	90 e0       	ldi	r25, 0x00	; 0
    26e4:	9c 83       	std	Y+4, r25	; 0x04
    26e6:	8b 83       	std	Y+3, r24	; 0x03
    26e8:	8b 81       	ldd	r24, Y+3	; 0x03
    26ea:	9c 81       	ldd	r25, Y+4	; 0x04
    26ec:	01 97       	sbiw	r24, 0x01	; 1
    26ee:	f1 f7       	brne	.-4      	; 0x26ec <Receive_PASS+0xea>
    26f0:	9c 83       	std	Y+4, r25	; 0x04
    26f2:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    26f4:	8d 81       	ldd	r24, Y+5	; 0x05
    26f6:	9e 81       	ldd	r25, Y+6	; 0x06
    26f8:	01 97       	sbiw	r24, 0x01	; 1
    26fa:	9e 83       	std	Y+6, r25	; 0x06
    26fc:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    26fe:	8d 81       	ldd	r24, Y+5	; 0x05
    2700:	9e 81       	ldd	r25, Y+6	; 0x06
    2702:	00 97       	sbiw	r24, 0x00	; 0
    2704:	69 f7       	brne	.-38     	; 0x26e0 <Receive_PASS+0xde>
    2706:	14 c0       	rjmp	.+40     	; 0x2730 <Receive_PASS+0x12e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2708:	6f 81       	ldd	r22, Y+7	; 0x07
    270a:	78 85       	ldd	r23, Y+8	; 0x08
    270c:	89 85       	ldd	r24, Y+9	; 0x09
    270e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2710:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2714:	dc 01       	movw	r26, r24
    2716:	cb 01       	movw	r24, r22
    2718:	9e 83       	std	Y+6, r25	; 0x06
    271a:	8d 83       	std	Y+5, r24	; 0x05
    271c:	8d 81       	ldd	r24, Y+5	; 0x05
    271e:	9e 81       	ldd	r25, Y+6	; 0x06
    2720:	9a 83       	std	Y+2, r25	; 0x02
    2722:	89 83       	std	Y+1, r24	; 0x01
    2724:	89 81       	ldd	r24, Y+1	; 0x01
    2726:	9a 81       	ldd	r25, Y+2	; 0x02
    2728:	01 97       	sbiw	r24, 0x01	; 1
    272a:	f1 f7       	brne	.-4      	; 0x2728 <Receive_PASS+0x126>
    272c:	9a 83       	std	Y+2, r25	; 0x02
    272e:	89 83       	std	Y+1, r24	; 0x01
	{
		 userPass[counter] = UART_recieveByte();
	}
	 _delay_ms(500);
}
    2730:	61 96       	adiw	r28, 0x11	; 17
    2732:	0f b6       	in	r0, 0x3f	; 63
    2734:	f8 94       	cli
    2736:	de bf       	out	0x3e, r29	; 62
    2738:	0f be       	out	0x3f, r0	; 63
    273a:	cd bf       	out	0x3d, r28	; 61
    273c:	cf 91       	pop	r28
    273e:	df 91       	pop	r29
    2740:	1f 91       	pop	r17
    2742:	0f 91       	pop	r16
    2744:	08 95       	ret

00002746 <Compare_savedPass>:

uint8 Compare_savedPass(uint8 *userPass,uint8 *savedPass)
{
    2746:	df 93       	push	r29
    2748:	cf 93       	push	r28
    274a:	cd b7       	in	r28, 0x3d	; 61
    274c:	de b7       	in	r29, 0x3e	; 62
    274e:	a2 97       	sbiw	r28, 0x22	; 34
    2750:	0f b6       	in	r0, 0x3f	; 63
    2752:	f8 94       	cli
    2754:	de bf       	out	0x3e, r29	; 62
    2756:	0f be       	out	0x3f, r0	; 63
    2758:	cd bf       	out	0x3d, r28	; 61
    275a:	9f 8f       	std	Y+31, r25	; 0x1f
    275c:	8e 8f       	std	Y+30, r24	; 0x1e
    275e:	79 a3       	std	Y+33, r23	; 0x21
    2760:	68 a3       	std	Y+32, r22	; 0x20
	uint8 counter;
	for (counter =0;counter<PASS_LENGTH;counter++)
    2762:	1d 8e       	std	Y+29, r1	; 0x1d
    2764:	8d c0       	rjmp	.+282    	; 0x2880 <Compare_savedPass+0x13a>
	{
		if(userPass[counter] != savedPass[counter])
    2766:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2768:	28 2f       	mov	r18, r24
    276a:	30 e0       	ldi	r19, 0x00	; 0
    276c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    276e:	9f 8d       	ldd	r25, Y+31	; 0x1f
    2770:	fc 01       	movw	r30, r24
    2772:	e2 0f       	add	r30, r18
    2774:	f3 1f       	adc	r31, r19
    2776:	40 81       	ld	r20, Z
    2778:	8d 8d       	ldd	r24, Y+29	; 0x1d
    277a:	28 2f       	mov	r18, r24
    277c:	30 e0       	ldi	r19, 0x00	; 0
    277e:	88 a1       	ldd	r24, Y+32	; 0x20
    2780:	99 a1       	ldd	r25, Y+33	; 0x21
    2782:	fc 01       	movw	r30, r24
    2784:	e2 0f       	add	r30, r18
    2786:	f3 1f       	adc	r31, r19
    2788:	80 81       	ld	r24, Z
    278a:	48 17       	cp	r20, r24
    278c:	09 f4       	brne	.+2      	; 0x2790 <Compare_savedPass+0x4a>
    278e:	75 c0       	rjmp	.+234    	; 0x287a <Compare_savedPass+0x134>
    2790:	80 e0       	ldi	r24, 0x00	; 0
    2792:	90 e0       	ldi	r25, 0x00	; 0
    2794:	aa ef       	ldi	r26, 0xFA	; 250
    2796:	b3 e4       	ldi	r27, 0x43	; 67
    2798:	89 8f       	std	Y+25, r24	; 0x19
    279a:	9a 8f       	std	Y+26, r25	; 0x1a
    279c:	ab 8f       	std	Y+27, r26	; 0x1b
    279e:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    27a0:	69 8d       	ldd	r22, Y+25	; 0x19
    27a2:	7a 8d       	ldd	r23, Y+26	; 0x1a
    27a4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    27a6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    27a8:	20 e0       	ldi	r18, 0x00	; 0
    27aa:	30 e0       	ldi	r19, 0x00	; 0
    27ac:	4a ef       	ldi	r20, 0xFA	; 250
    27ae:	54 e4       	ldi	r21, 0x44	; 68
    27b0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    27b4:	dc 01       	movw	r26, r24
    27b6:	cb 01       	movw	r24, r22
    27b8:	8d 8b       	std	Y+21, r24	; 0x15
    27ba:	9e 8b       	std	Y+22, r25	; 0x16
    27bc:	af 8b       	std	Y+23, r26	; 0x17
    27be:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    27c0:	6d 89       	ldd	r22, Y+21	; 0x15
    27c2:	7e 89       	ldd	r23, Y+22	; 0x16
    27c4:	8f 89       	ldd	r24, Y+23	; 0x17
    27c6:	98 8d       	ldd	r25, Y+24	; 0x18
    27c8:	20 e0       	ldi	r18, 0x00	; 0
    27ca:	30 e0       	ldi	r19, 0x00	; 0
    27cc:	40 e8       	ldi	r20, 0x80	; 128
    27ce:	5f e3       	ldi	r21, 0x3F	; 63
    27d0:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    27d4:	88 23       	and	r24, r24
    27d6:	2c f4       	brge	.+10     	; 0x27e2 <Compare_savedPass+0x9c>
		__ticks = 1;
    27d8:	81 e0       	ldi	r24, 0x01	; 1
    27da:	90 e0       	ldi	r25, 0x00	; 0
    27dc:	9c 8b       	std	Y+20, r25	; 0x14
    27de:	8b 8b       	std	Y+19, r24	; 0x13
    27e0:	3f c0       	rjmp	.+126    	; 0x2860 <Compare_savedPass+0x11a>
	else if (__tmp > 65535)
    27e2:	6d 89       	ldd	r22, Y+21	; 0x15
    27e4:	7e 89       	ldd	r23, Y+22	; 0x16
    27e6:	8f 89       	ldd	r24, Y+23	; 0x17
    27e8:	98 8d       	ldd	r25, Y+24	; 0x18
    27ea:	20 e0       	ldi	r18, 0x00	; 0
    27ec:	3f ef       	ldi	r19, 0xFF	; 255
    27ee:	4f e7       	ldi	r20, 0x7F	; 127
    27f0:	57 e4       	ldi	r21, 0x47	; 71
    27f2:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    27f6:	18 16       	cp	r1, r24
    27f8:	4c f5       	brge	.+82     	; 0x284c <Compare_savedPass+0x106>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    27fa:	69 8d       	ldd	r22, Y+25	; 0x19
    27fc:	7a 8d       	ldd	r23, Y+26	; 0x1a
    27fe:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2800:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2802:	20 e0       	ldi	r18, 0x00	; 0
    2804:	30 e0       	ldi	r19, 0x00	; 0
    2806:	40 e2       	ldi	r20, 0x20	; 32
    2808:	51 e4       	ldi	r21, 0x41	; 65
    280a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    280e:	dc 01       	movw	r26, r24
    2810:	cb 01       	movw	r24, r22
    2812:	bc 01       	movw	r22, r24
    2814:	cd 01       	movw	r24, r26
    2816:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    281a:	dc 01       	movw	r26, r24
    281c:	cb 01       	movw	r24, r22
    281e:	9c 8b       	std	Y+20, r25	; 0x14
    2820:	8b 8b       	std	Y+19, r24	; 0x13
    2822:	0f c0       	rjmp	.+30     	; 0x2842 <Compare_savedPass+0xfc>
    2824:	88 ec       	ldi	r24, 0xC8	; 200
    2826:	90 e0       	ldi	r25, 0x00	; 0
    2828:	9a 8b       	std	Y+18, r25	; 0x12
    282a:	89 8b       	std	Y+17, r24	; 0x11
    282c:	89 89       	ldd	r24, Y+17	; 0x11
    282e:	9a 89       	ldd	r25, Y+18	; 0x12
    2830:	01 97       	sbiw	r24, 0x01	; 1
    2832:	f1 f7       	brne	.-4      	; 0x2830 <Compare_savedPass+0xea>
    2834:	9a 8b       	std	Y+18, r25	; 0x12
    2836:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2838:	8b 89       	ldd	r24, Y+19	; 0x13
    283a:	9c 89       	ldd	r25, Y+20	; 0x14
    283c:	01 97       	sbiw	r24, 0x01	; 1
    283e:	9c 8b       	std	Y+20, r25	; 0x14
    2840:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2842:	8b 89       	ldd	r24, Y+19	; 0x13
    2844:	9c 89       	ldd	r25, Y+20	; 0x14
    2846:	00 97       	sbiw	r24, 0x00	; 0
    2848:	69 f7       	brne	.-38     	; 0x2824 <Compare_savedPass+0xde>
    284a:	14 c0       	rjmp	.+40     	; 0x2874 <Compare_savedPass+0x12e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    284c:	6d 89       	ldd	r22, Y+21	; 0x15
    284e:	7e 89       	ldd	r23, Y+22	; 0x16
    2850:	8f 89       	ldd	r24, Y+23	; 0x17
    2852:	98 8d       	ldd	r25, Y+24	; 0x18
    2854:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2858:	dc 01       	movw	r26, r24
    285a:	cb 01       	movw	r24, r22
    285c:	9c 8b       	std	Y+20, r25	; 0x14
    285e:	8b 8b       	std	Y+19, r24	; 0x13
    2860:	8b 89       	ldd	r24, Y+19	; 0x13
    2862:	9c 89       	ldd	r25, Y+20	; 0x14
    2864:	98 8b       	std	Y+16, r25	; 0x10
    2866:	8f 87       	std	Y+15, r24	; 0x0f
    2868:	8f 85       	ldd	r24, Y+15	; 0x0f
    286a:	98 89       	ldd	r25, Y+16	; 0x10
    286c:	01 97       	sbiw	r24, 0x01	; 1
    286e:	f1 f7       	brne	.-4      	; 0x286c <Compare_savedPass+0x126>
    2870:	98 8b       	std	Y+16, r25	; 0x10
    2872:	8f 87       	std	Y+15, r24	; 0x0f
		{
			 _delay_ms(500);
			 return INCORRECT_PASSWORD;
    2874:	81 e0       	ldi	r24, 0x01	; 1
    2876:	8a a3       	std	Y+34, r24	; 0x22
    2878:	7b c0       	rjmp	.+246    	; 0x2970 <Compare_savedPass+0x22a>
}

uint8 Compare_savedPass(uint8 *userPass,uint8 *savedPass)
{
	uint8 counter;
	for (counter =0;counter<PASS_LENGTH;counter++)
    287a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    287c:	8f 5f       	subi	r24, 0xFF	; 255
    287e:	8d 8f       	std	Y+29, r24	; 0x1d
    2880:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2882:	85 30       	cpi	r24, 0x05	; 5
    2884:	08 f4       	brcc	.+2      	; 0x2888 <Compare_savedPass+0x142>
    2886:	6f cf       	rjmp	.-290    	; 0x2766 <Compare_savedPass+0x20>
    2888:	80 e0       	ldi	r24, 0x00	; 0
    288a:	90 e0       	ldi	r25, 0x00	; 0
    288c:	aa ef       	ldi	r26, 0xFA	; 250
    288e:	b3 e4       	ldi	r27, 0x43	; 67
    2890:	8b 87       	std	Y+11, r24	; 0x0b
    2892:	9c 87       	std	Y+12, r25	; 0x0c
    2894:	ad 87       	std	Y+13, r26	; 0x0d
    2896:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2898:	6b 85       	ldd	r22, Y+11	; 0x0b
    289a:	7c 85       	ldd	r23, Y+12	; 0x0c
    289c:	8d 85       	ldd	r24, Y+13	; 0x0d
    289e:	9e 85       	ldd	r25, Y+14	; 0x0e
    28a0:	20 e0       	ldi	r18, 0x00	; 0
    28a2:	30 e0       	ldi	r19, 0x00	; 0
    28a4:	4a ef       	ldi	r20, 0xFA	; 250
    28a6:	54 e4       	ldi	r21, 0x44	; 68
    28a8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    28ac:	dc 01       	movw	r26, r24
    28ae:	cb 01       	movw	r24, r22
    28b0:	8f 83       	std	Y+7, r24	; 0x07
    28b2:	98 87       	std	Y+8, r25	; 0x08
    28b4:	a9 87       	std	Y+9, r26	; 0x09
    28b6:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    28b8:	6f 81       	ldd	r22, Y+7	; 0x07
    28ba:	78 85       	ldd	r23, Y+8	; 0x08
    28bc:	89 85       	ldd	r24, Y+9	; 0x09
    28be:	9a 85       	ldd	r25, Y+10	; 0x0a
    28c0:	20 e0       	ldi	r18, 0x00	; 0
    28c2:	30 e0       	ldi	r19, 0x00	; 0
    28c4:	40 e8       	ldi	r20, 0x80	; 128
    28c6:	5f e3       	ldi	r21, 0x3F	; 63
    28c8:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    28cc:	88 23       	and	r24, r24
    28ce:	2c f4       	brge	.+10     	; 0x28da <Compare_savedPass+0x194>
		__ticks = 1;
    28d0:	81 e0       	ldi	r24, 0x01	; 1
    28d2:	90 e0       	ldi	r25, 0x00	; 0
    28d4:	9e 83       	std	Y+6, r25	; 0x06
    28d6:	8d 83       	std	Y+5, r24	; 0x05
    28d8:	3f c0       	rjmp	.+126    	; 0x2958 <Compare_savedPass+0x212>
	else if (__tmp > 65535)
    28da:	6f 81       	ldd	r22, Y+7	; 0x07
    28dc:	78 85       	ldd	r23, Y+8	; 0x08
    28de:	89 85       	ldd	r24, Y+9	; 0x09
    28e0:	9a 85       	ldd	r25, Y+10	; 0x0a
    28e2:	20 e0       	ldi	r18, 0x00	; 0
    28e4:	3f ef       	ldi	r19, 0xFF	; 255
    28e6:	4f e7       	ldi	r20, 0x7F	; 127
    28e8:	57 e4       	ldi	r21, 0x47	; 71
    28ea:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    28ee:	18 16       	cp	r1, r24
    28f0:	4c f5       	brge	.+82     	; 0x2944 <Compare_savedPass+0x1fe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    28f2:	6b 85       	ldd	r22, Y+11	; 0x0b
    28f4:	7c 85       	ldd	r23, Y+12	; 0x0c
    28f6:	8d 85       	ldd	r24, Y+13	; 0x0d
    28f8:	9e 85       	ldd	r25, Y+14	; 0x0e
    28fa:	20 e0       	ldi	r18, 0x00	; 0
    28fc:	30 e0       	ldi	r19, 0x00	; 0
    28fe:	40 e2       	ldi	r20, 0x20	; 32
    2900:	51 e4       	ldi	r21, 0x41	; 65
    2902:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2906:	dc 01       	movw	r26, r24
    2908:	cb 01       	movw	r24, r22
    290a:	bc 01       	movw	r22, r24
    290c:	cd 01       	movw	r24, r26
    290e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2912:	dc 01       	movw	r26, r24
    2914:	cb 01       	movw	r24, r22
    2916:	9e 83       	std	Y+6, r25	; 0x06
    2918:	8d 83       	std	Y+5, r24	; 0x05
    291a:	0f c0       	rjmp	.+30     	; 0x293a <Compare_savedPass+0x1f4>
    291c:	88 ec       	ldi	r24, 0xC8	; 200
    291e:	90 e0       	ldi	r25, 0x00	; 0
    2920:	9c 83       	std	Y+4, r25	; 0x04
    2922:	8b 83       	std	Y+3, r24	; 0x03
    2924:	8b 81       	ldd	r24, Y+3	; 0x03
    2926:	9c 81       	ldd	r25, Y+4	; 0x04
    2928:	01 97       	sbiw	r24, 0x01	; 1
    292a:	f1 f7       	brne	.-4      	; 0x2928 <Compare_savedPass+0x1e2>
    292c:	9c 83       	std	Y+4, r25	; 0x04
    292e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2930:	8d 81       	ldd	r24, Y+5	; 0x05
    2932:	9e 81       	ldd	r25, Y+6	; 0x06
    2934:	01 97       	sbiw	r24, 0x01	; 1
    2936:	9e 83       	std	Y+6, r25	; 0x06
    2938:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    293a:	8d 81       	ldd	r24, Y+5	; 0x05
    293c:	9e 81       	ldd	r25, Y+6	; 0x06
    293e:	00 97       	sbiw	r24, 0x00	; 0
    2940:	69 f7       	brne	.-38     	; 0x291c <Compare_savedPass+0x1d6>
    2942:	14 c0       	rjmp	.+40     	; 0x296c <Compare_savedPass+0x226>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2944:	6f 81       	ldd	r22, Y+7	; 0x07
    2946:	78 85       	ldd	r23, Y+8	; 0x08
    2948:	89 85       	ldd	r24, Y+9	; 0x09
    294a:	9a 85       	ldd	r25, Y+10	; 0x0a
    294c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2950:	dc 01       	movw	r26, r24
    2952:	cb 01       	movw	r24, r22
    2954:	9e 83       	std	Y+6, r25	; 0x06
    2956:	8d 83       	std	Y+5, r24	; 0x05
    2958:	8d 81       	ldd	r24, Y+5	; 0x05
    295a:	9e 81       	ldd	r25, Y+6	; 0x06
    295c:	9a 83       	std	Y+2, r25	; 0x02
    295e:	89 83       	std	Y+1, r24	; 0x01
    2960:	89 81       	ldd	r24, Y+1	; 0x01
    2962:	9a 81       	ldd	r25, Y+2	; 0x02
    2964:	01 97       	sbiw	r24, 0x01	; 1
    2966:	f1 f7       	brne	.-4      	; 0x2964 <Compare_savedPass+0x21e>
    2968:	9a 83       	std	Y+2, r25	; 0x02
    296a:	89 83       	std	Y+1, r24	; 0x01
			 _delay_ms(500);
			 return INCORRECT_PASSWORD;
		}
	}
	 _delay_ms(500);
	 return CORRECT_PASSWORD;
    296c:	82 e0       	ldi	r24, 0x02	; 2
    296e:	8a a3       	std	Y+34, r24	; 0x22
    2970:	8a a1       	ldd	r24, Y+34	; 0x22
}
    2972:	a2 96       	adiw	r28, 0x22	; 34
    2974:	0f b6       	in	r0, 0x3f	; 63
    2976:	f8 94       	cli
    2978:	de bf       	out	0x3e, r29	; 62
    297a:	0f be       	out	0x3f, r0	; 63
    297c:	cd bf       	out	0x3d, r28	; 61
    297e:	cf 91       	pop	r28
    2980:	df 91       	pop	r29
    2982:	08 95       	ret

00002984 <handlePlusOption>:

/*
 * Handling (+) & (-) options
 */
void handlePlusOption(uint8 plus_result)
{
    2984:	df 93       	push	r29
    2986:	cf 93       	push	r28
    2988:	00 d0       	rcall	.+0      	; 0x298a <handlePlusOption+0x6>
    298a:	0f 92       	push	r0
    298c:	cd b7       	in	r28, 0x3d	; 61
    298e:	de b7       	in	r29, 0x3e	; 62
    2990:	89 83       	std	Y+1, r24	; 0x01
	switch (plus_result)
    2992:	89 81       	ldd	r24, Y+1	; 0x01
    2994:	28 2f       	mov	r18, r24
    2996:	30 e0       	ldi	r19, 0x00	; 0
    2998:	3b 83       	std	Y+3, r19	; 0x03
    299a:	2a 83       	std	Y+2, r18	; 0x02
    299c:	8a 81       	ldd	r24, Y+2	; 0x02
    299e:	9b 81       	ldd	r25, Y+3	; 0x03
    29a0:	81 30       	cpi	r24, 0x01	; 1
    29a2:	91 05       	cpc	r25, r1
    29a4:	a9 f0       	breq	.+42     	; 0x29d0 <handlePlusOption+0x4c>
    29a6:	2a 81       	ldd	r18, Y+2	; 0x02
    29a8:	3b 81       	ldd	r19, Y+3	; 0x03
    29aa:	22 30       	cpi	r18, 0x02	; 2
    29ac:	31 05       	cpc	r19, r1
    29ae:	41 f5       	brne	.+80     	; 0x2a00 <handlePlusOption+0x7c>
	{
		case CORRECT_PASSWORD:
			while (UART_recieveByte() != TRANSMIT);
    29b0:	0e 94 08 07 	call	0xe10	; 0xe10 <UART_recieveByte>
    29b4:	83 30       	cpi	r24, 0x03	; 3
    29b6:	e1 f7       	brne	.-8      	; 0x29b0 <handlePlusOption+0x2c>
			UART_sendByte(CORRECT_PASSWORD);
    29b8:	82 e0       	ldi	r24, 0x02	; 2
    29ba:	0e 94 f1 06 	call	0xde2	; 0xde2 <UART_sendByte>
			remaining_trials =3;
    29be:	83 e0       	ldi	r24, 0x03	; 3
    29c0:	80 93 68 00 	sts	0x0068, r24
			break_cond = 1;
    29c4:	81 e0       	ldi	r24, 0x01	; 1
    29c6:	80 93 69 00 	sts	0x0069, r24
			/*perform door locking*/
			doorLocker();
    29ca:	0e 94 2c 0f 	call	0x1e58	; 0x1e58 <doorLocker>
    29ce:	18 c0       	rjmp	.+48     	; 0x2a00 <handlePlusOption+0x7c>

			break;
		case INCORRECT_PASSWORD:
			while (UART_recieveByte() != TRANSMIT);
    29d0:	0e 94 08 07 	call	0xe10	; 0xe10 <UART_recieveByte>
    29d4:	83 30       	cpi	r24, 0x03	; 3
    29d6:	e1 f7       	brne	.-8      	; 0x29d0 <handlePlusOption+0x4c>
			UART_sendByte(INCORRECT_PASSWORD);
    29d8:	81 e0       	ldi	r24, 0x01	; 1
    29da:	0e 94 f1 06 	call	0xde2	; 0xde2 <UART_sendByte>
			remaining_trials--;
    29de:	80 91 68 00 	lds	r24, 0x0068
    29e2:	81 50       	subi	r24, 0x01	; 1
    29e4:	80 93 68 00 	sts	0x0068, r24
			if(remaining_trials == 0)
    29e8:	80 91 68 00 	lds	r24, 0x0068
    29ec:	88 23       	and	r24, r24
    29ee:	41 f4       	brne	.+16     	; 0x2a00 <handlePlusOption+0x7c>
			{
				remaining_trials = 3;
    29f0:	83 e0       	ldi	r24, 0x03	; 3
    29f2:	80 93 68 00 	sts	0x0068, r24
				break_cond = 1;
    29f6:	81 e0       	ldi	r24, 0x01	; 1
    29f8:	80 93 69 00 	sts	0x0069, r24
				/*triggers alarm after 0 trials*/
				Alarm();
    29fc:	0e 94 4c 0f 	call	0x1e98	; 0x1e98 <Alarm>
			}
			break;
	}
}
    2a00:	0f 90       	pop	r0
    2a02:	0f 90       	pop	r0
    2a04:	0f 90       	pop	r0
    2a06:	cf 91       	pop	r28
    2a08:	df 91       	pop	r29
    2a0a:	08 95       	ret

00002a0c <handleMinusOption>:
void handleMinusOption(uint8 minus_result)
{
    2a0c:	df 93       	push	r29
    2a0e:	cf 93       	push	r28
    2a10:	00 d0       	rcall	.+0      	; 0x2a12 <handleMinusOption+0x6>
    2a12:	0f 92       	push	r0
    2a14:	cd b7       	in	r28, 0x3d	; 61
    2a16:	de b7       	in	r29, 0x3e	; 62
    2a18:	89 83       	std	Y+1, r24	; 0x01
	switch (minus_result)
    2a1a:	89 81       	ldd	r24, Y+1	; 0x01
    2a1c:	28 2f       	mov	r18, r24
    2a1e:	30 e0       	ldi	r19, 0x00	; 0
    2a20:	3b 83       	std	Y+3, r19	; 0x03
    2a22:	2a 83       	std	Y+2, r18	; 0x02
    2a24:	8a 81       	ldd	r24, Y+2	; 0x02
    2a26:	9b 81       	ldd	r25, Y+3	; 0x03
    2a28:	81 30       	cpi	r24, 0x01	; 1
    2a2a:	91 05       	cpc	r25, r1
    2a2c:	79 f0       	breq	.+30     	; 0x2a4c <handleMinusOption+0x40>
    2a2e:	2a 81       	ldd	r18, Y+2	; 0x02
    2a30:	3b 81       	ldd	r19, Y+3	; 0x03
    2a32:	22 30       	cpi	r18, 0x02	; 2
    2a34:	31 05       	cpc	r19, r1
    2a36:	11 f5       	brne	.+68     	; 0x2a7c <handleMinusOption+0x70>
	{
		case CORRECT_PASSWORD:
					while (UART_recieveByte() != TRANSMIT);
    2a38:	0e 94 08 07 	call	0xe10	; 0xe10 <UART_recieveByte>
    2a3c:	83 30       	cpi	r24, 0x03	; 3
    2a3e:	e1 f7       	brne	.-8      	; 0x2a38 <handleMinusOption+0x2c>
					UART_sendByte(CORRECT_PASSWORD);
    2a40:	82 e0       	ldi	r24, 0x02	; 2
    2a42:	0e 94 f1 06 	call	0xde2	; 0xde2 <UART_sendByte>
					break_cond = 0;
    2a46:	10 92 69 00 	sts	0x0069, r1
    2a4a:	18 c0       	rjmp	.+48     	; 0x2a7c <handleMinusOption+0x70>
					/*will go to MC1 and change pass*/
					break;
		case INCORRECT_PASSWORD:
					while (UART_recieveByte() != TRANSMIT);
    2a4c:	0e 94 08 07 	call	0xe10	; 0xe10 <UART_recieveByte>
    2a50:	83 30       	cpi	r24, 0x03	; 3
    2a52:	e1 f7       	brne	.-8      	; 0x2a4c <handleMinusOption+0x40>
					UART_sendByte(INCORRECT_PASSWORD);
    2a54:	81 e0       	ldi	r24, 0x01	; 1
    2a56:	0e 94 f1 06 	call	0xde2	; 0xde2 <UART_sendByte>
					remaining_trials--;
    2a5a:	80 91 68 00 	lds	r24, 0x0068
    2a5e:	81 50       	subi	r24, 0x01	; 1
    2a60:	80 93 68 00 	sts	0x0068, r24
					if(remaining_trials == 0)
    2a64:	80 91 68 00 	lds	r24, 0x0068
    2a68:	88 23       	and	r24, r24
    2a6a:	41 f4       	brne	.+16     	; 0x2a7c <handleMinusOption+0x70>
					{
						remaining_trials = 3;
    2a6c:	83 e0       	ldi	r24, 0x03	; 3
    2a6e:	80 93 68 00 	sts	0x0068, r24
						break_cond = 1;
    2a72:	81 e0       	ldi	r24, 0x01	; 1
    2a74:	80 93 69 00 	sts	0x0069, r24
						/*triggers alarm*/
						Alarm();
    2a78:	0e 94 4c 0f 	call	0x1e98	; 0x1e98 <Alarm>
					}
					break;
	}
}
    2a7c:	0f 90       	pop	r0
    2a7e:	0f 90       	pop	r0
    2a80:	0f 90       	pop	r0
    2a82:	cf 91       	pop	r28
    2a84:	df 91       	pop	r29
    2a86:	08 95       	ret

00002a88 <__udivmodhi4>:
    2a88:	aa 1b       	sub	r26, r26
    2a8a:	bb 1b       	sub	r27, r27
    2a8c:	51 e1       	ldi	r21, 0x11	; 17
    2a8e:	07 c0       	rjmp	.+14     	; 0x2a9e <__udivmodhi4_ep>

00002a90 <__udivmodhi4_loop>:
    2a90:	aa 1f       	adc	r26, r26
    2a92:	bb 1f       	adc	r27, r27
    2a94:	a6 17       	cp	r26, r22
    2a96:	b7 07       	cpc	r27, r23
    2a98:	10 f0       	brcs	.+4      	; 0x2a9e <__udivmodhi4_ep>
    2a9a:	a6 1b       	sub	r26, r22
    2a9c:	b7 0b       	sbc	r27, r23

00002a9e <__udivmodhi4_ep>:
    2a9e:	88 1f       	adc	r24, r24
    2aa0:	99 1f       	adc	r25, r25
    2aa2:	5a 95       	dec	r21
    2aa4:	a9 f7       	brne	.-22     	; 0x2a90 <__udivmodhi4_loop>
    2aa6:	80 95       	com	r24
    2aa8:	90 95       	com	r25
    2aaa:	bc 01       	movw	r22, r24
    2aac:	cd 01       	movw	r24, r26
    2aae:	08 95       	ret

00002ab0 <__udivmodsi4>:
    2ab0:	a1 e2       	ldi	r26, 0x21	; 33
    2ab2:	1a 2e       	mov	r1, r26
    2ab4:	aa 1b       	sub	r26, r26
    2ab6:	bb 1b       	sub	r27, r27
    2ab8:	fd 01       	movw	r30, r26
    2aba:	0d c0       	rjmp	.+26     	; 0x2ad6 <__udivmodsi4_ep>

00002abc <__udivmodsi4_loop>:
    2abc:	aa 1f       	adc	r26, r26
    2abe:	bb 1f       	adc	r27, r27
    2ac0:	ee 1f       	adc	r30, r30
    2ac2:	ff 1f       	adc	r31, r31
    2ac4:	a2 17       	cp	r26, r18
    2ac6:	b3 07       	cpc	r27, r19
    2ac8:	e4 07       	cpc	r30, r20
    2aca:	f5 07       	cpc	r31, r21
    2acc:	20 f0       	brcs	.+8      	; 0x2ad6 <__udivmodsi4_ep>
    2ace:	a2 1b       	sub	r26, r18
    2ad0:	b3 0b       	sbc	r27, r19
    2ad2:	e4 0b       	sbc	r30, r20
    2ad4:	f5 0b       	sbc	r31, r21

00002ad6 <__udivmodsi4_ep>:
    2ad6:	66 1f       	adc	r22, r22
    2ad8:	77 1f       	adc	r23, r23
    2ada:	88 1f       	adc	r24, r24
    2adc:	99 1f       	adc	r25, r25
    2ade:	1a 94       	dec	r1
    2ae0:	69 f7       	brne	.-38     	; 0x2abc <__udivmodsi4_loop>
    2ae2:	60 95       	com	r22
    2ae4:	70 95       	com	r23
    2ae6:	80 95       	com	r24
    2ae8:	90 95       	com	r25
    2aea:	9b 01       	movw	r18, r22
    2aec:	ac 01       	movw	r20, r24
    2aee:	bd 01       	movw	r22, r26
    2af0:	cf 01       	movw	r24, r30
    2af2:	08 95       	ret

00002af4 <__prologue_saves__>:
    2af4:	2f 92       	push	r2
    2af6:	3f 92       	push	r3
    2af8:	4f 92       	push	r4
    2afa:	5f 92       	push	r5
    2afc:	6f 92       	push	r6
    2afe:	7f 92       	push	r7
    2b00:	8f 92       	push	r8
    2b02:	9f 92       	push	r9
    2b04:	af 92       	push	r10
    2b06:	bf 92       	push	r11
    2b08:	cf 92       	push	r12
    2b0a:	df 92       	push	r13
    2b0c:	ef 92       	push	r14
    2b0e:	ff 92       	push	r15
    2b10:	0f 93       	push	r16
    2b12:	1f 93       	push	r17
    2b14:	cf 93       	push	r28
    2b16:	df 93       	push	r29
    2b18:	cd b7       	in	r28, 0x3d	; 61
    2b1a:	de b7       	in	r29, 0x3e	; 62
    2b1c:	ca 1b       	sub	r28, r26
    2b1e:	db 0b       	sbc	r29, r27
    2b20:	0f b6       	in	r0, 0x3f	; 63
    2b22:	f8 94       	cli
    2b24:	de bf       	out	0x3e, r29	; 62
    2b26:	0f be       	out	0x3f, r0	; 63
    2b28:	cd bf       	out	0x3d, r28	; 61
    2b2a:	09 94       	ijmp

00002b2c <__epilogue_restores__>:
    2b2c:	2a 88       	ldd	r2, Y+18	; 0x12
    2b2e:	39 88       	ldd	r3, Y+17	; 0x11
    2b30:	48 88       	ldd	r4, Y+16	; 0x10
    2b32:	5f 84       	ldd	r5, Y+15	; 0x0f
    2b34:	6e 84       	ldd	r6, Y+14	; 0x0e
    2b36:	7d 84       	ldd	r7, Y+13	; 0x0d
    2b38:	8c 84       	ldd	r8, Y+12	; 0x0c
    2b3a:	9b 84       	ldd	r9, Y+11	; 0x0b
    2b3c:	aa 84       	ldd	r10, Y+10	; 0x0a
    2b3e:	b9 84       	ldd	r11, Y+9	; 0x09
    2b40:	c8 84       	ldd	r12, Y+8	; 0x08
    2b42:	df 80       	ldd	r13, Y+7	; 0x07
    2b44:	ee 80       	ldd	r14, Y+6	; 0x06
    2b46:	fd 80       	ldd	r15, Y+5	; 0x05
    2b48:	0c 81       	ldd	r16, Y+4	; 0x04
    2b4a:	1b 81       	ldd	r17, Y+3	; 0x03
    2b4c:	aa 81       	ldd	r26, Y+2	; 0x02
    2b4e:	b9 81       	ldd	r27, Y+1	; 0x01
    2b50:	ce 0f       	add	r28, r30
    2b52:	d1 1d       	adc	r29, r1
    2b54:	0f b6       	in	r0, 0x3f	; 63
    2b56:	f8 94       	cli
    2b58:	de bf       	out	0x3e, r29	; 62
    2b5a:	0f be       	out	0x3f, r0	; 63
    2b5c:	cd bf       	out	0x3d, r28	; 61
    2b5e:	ed 01       	movw	r28, r26
    2b60:	08 95       	ret

00002b62 <_exit>:
    2b62:	f8 94       	cli

00002b64 <__stop_program>:
    2b64:	ff cf       	rjmp	.-2      	; 0x2b64 <__stop_program>
